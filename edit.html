<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éŸ³é¢‘ç¼–è¾‘</title>
    <style>
        /* CSSæ ·å¼ä¿æŒä¸å˜ï¼Œä¸åŸå§‹ä»£ç ç›¸åŒ */
        :root {
            --primary-color: #3498db;
            --secondary-color: #2980b9;
            --accent-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #2c3e50;
            --success-color: #2ecc71;
            --warning-color: #f39c12;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: var(--dark-color);
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1rem;
            opacity: 0.9;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 0.63fr 2.37fr;
            /* gap: 20px; */
            /* padding: 20px; */
        }
        
        .sidebar {
            /* background: var(--light-color); */
            border-radius: 8px;
            /* padding: 15px; */
        }
        
        .main-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        
        .section-title {
            font-size: 1.3rem;
            margin-bottom: 13px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--light-color);
            color: var(--secondary-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .upload-area {
            border: 2px dashed var(--primary-color);
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 20px;
        }
        
        .upload-area:hover {
            background: rgba(52, 152, 219, 0.05);
        }
        
        .upload-icon {
            font-size: 3rem;
            color: var(--primary-color);
            margin-bottom: 10px;
        }
        
        .audio-list {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .audio-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            background: white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .audio-item.active {
            border-left: 4px solid var(--primary-color);
        }
        
        .audio-name {
            flex: 1;
            font-weight: 500;
            font-size: 13px;
        }
        
        .audio-controls {
            display: flex;
            gap: 5px;
        }
        
        .btn {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .btn-primary {
            background: var(--primary-color);
            color: white;
        }
        
        .btn-primary:hover {
            background: var(--secondary-color);
        }
        
        .btn-danger {
            background: var(--accent-color);
            color: white;
        }
        
        .btn-danger:hover {
            background: #c0392b;
        }
        
        .btn-success {
            background: var(--success-color);
            color: white;
        }
        
        .btn-success:hover {
            background: #27ae60;
        }
        
        .btn-warning {
            background: var(--warning-color);
            color: white;
        }
        
        .btn-warning:hover {
            background: #e67e22;
        }
        
        .btn-outline {
            background: transparent;
            border: 1px solid var(--primary-color);
            color: var(--primary-color);
        }
        
        .btn-outline:hover {
            background: rgba(52, 152, 219, 0.1);
        }
        
        .btn-outline.active {
            background: var(--primary-color);
            color: white;
        }
        
        .waveform-container {
            background: var(--dark-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            position: relative;
            display: flex;
        }
        
        #waveform {
            width: 100%;
            height: 150px;
            background: #1a2530;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }
        
        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--accent-color);
            z-index: 10;
        }
        
        .selection {
            position: absolute;
            top: 0;
            bottom: 0;
            background: rgba(52, 152, 219, 0.3);
            z-index: 5;
        }
        
        .selection-handle {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background: rgba(255, 255, 255, 0.9);
            cursor: col-resize;
            z-index: 15;
        }

        .selection-handle::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            left: -5px;
            right: -5px;
            background: transparent;
        }
        
        .selection-handle:hover {
            background: rgba(255, 255, 255, 1);
        }
        
        .selection-handle.start {
            left: 0;
        }
        
        .selection-handle.end {
            right: 0;
        }
        
        .playback-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .time-display {
            text-align: center;
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-bottom: 15px;
        }
        
        .clip-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .clip-list {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .clip-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            border-radius: 4px;
            margin-bottom: 5px;
            background: var(--light-color);
        }
        
        .clip-name {
            flex: 1;
        }
        
        .clip-controls-buttons {
            display: flex;
            gap: 5px;
        }
        
        .clip-order-controls {
            display: flex;
            flex-direction: column;
            gap: 2px;
            margin-right: 5px;
        }
        
        .order-btn {
            padding: 2px 5px;
            font-size: 0.7rem;
            background: #95a5a6;
            color: white;
            border: none;
            border-radius: 2px;
            cursor: pointer;
        }
        
        .order-btn:hover {
            background: #7f8c8d;
        }
        
        .order-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        
        .shortcuts {
            margin-top: 20px;
            font-size: 0.85rem;
        }
        
        .shortcut-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.8rem;
        }
        
        .key {
            background: var(--dark-color);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
        }
        
        .status-bar {
            background: var(--light-color);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
        }
        
        .progress {
            height: 5px;
            background: #ddd;
            border-radius: 5px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: var(--primary-color);
            width: 0%;
            transition: width 0.3s;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        .hidden {
            display: none;
        }
        
        .rename-input {
            width: 100%;
            padding: 4px 8px;
            border: 1px solid var(--primary-color);
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .zoom-slider {
            flex: 1;
        }
        
        .zoom-value {
            min-width: 60px;
            text-align: center;
            font-size: 0.9rem;
        }
        
        .scroll-container {
            width: 100%;
            overflow-x: auto;
            margin-top: 10px;
            border-radius: 4px;
            background: #2c3e50;
        }
        
        .scroll-content {
            height: 10px;
            min-width: 100%;
        }
        
        .scroll-thumb {
            height: 100%;
            background: rgba(52, 152, 219, 0.7);
            border-radius: 4px;
            cursor: grab;
            position: relative;
        }
        
        .scroll-thumb:active {
            cursor: grabbing;
        }
        
        /* æ–°å¢ï¼šå“åº¦æ§åˆ¶æ»‘åŠ¨æ¡æ ·å¼ - å·²ä¿®æ”¹å¢åŠ é•¿åº¦ */
        .amplitude-control-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-left: -32px;
            margin-right: -47px;
            width: 110px; /* å¢åŠ å®½åº¦ä»¥é€‚åº”æ›´é•¿çš„æ»‘åŠ¨æ¡ */
            padding: 0;
            justify-content: center;
        }
        
        .amplitude-label {
            color: white;
            font-size: 0.8rem;
            margin-bottom: 10px;
        }
        
        .amplitude-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100px;
            height: 8px;
            background: #ddd;
            border-radius: 4px;
            transform: rotate(-90deg);
            transform-origin: center;
            margin: 41px 0;
        }
        
        .amplitude-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }
        
        .amplitude-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            border: none;
        }
        
        .amplitude-value {
            color: white;
            font-size: 0.8rem;
            margin-top: 10px;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .clip-controls-buttons {
                flex-direction: column;
            }
            
            .section-title {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .clip-controls {
                flex-direction: column;
            }
            
            .amplitude-control-container {
                margin-left: 0;
                margin-top: 15px;
                width: 100%;
            }
            
            .amplitude-slider {
                transform: rotate(0deg);
                width: 100%;
                margin: 10px 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>éŸ³é¢‘ç¼–è¾‘å™¨</h1>
            <p class="subtitle">ä¸Šä¼ ã€ç¼–è¾‘ã€æå–å’Œæ‹¼æ¥éŸ³é¢‘æ–‡ä»¶ï¼ˆæ”¯æŒWAVã€MP3ã€M4Aï¼Œè‡ªåŠ¨è½¬æ¢ä¸º8kHzï¼‰</p>
        </header>
        
        <div class="status-bar">
            <span id="statusMessage">å‡†å¤‡å°±ç»ª - ç²˜è´´åè‡ªåŠ¨é€‰æ‹©ç²˜è´´å†…å®¹</span>
            <span id="autoSaveStatus">è‡ªåŠ¨ä¿å­˜å·²å¯ç”¨</span>
        </div>
        <div class="main-content">
            <div class="sidebar">
                <div class="section">
                    <h2 class="section-title">ä¸Šä¼ éŸ³é¢‘</h2>
                    <div class="upload-area" id="uploadArea">
                        <div class="upload-icon">ğŸµ</div>
                        <p style="font-size:small;">ç‚¹å‡»æˆ–æ‹–æ”¾éŸ³é¢‘æ–‡ä»¶åˆ°è¿™é‡Œï¼ˆæ”¯æŒWAVã€MP3ã€M4Aï¼Œè‡ªåŠ¨è½¬æ¢ä¸º8kHzï¼‰</p>
                        <input type="file" id="fileInput" accept=".wav,.mp3,.m4a" multiple class="hidden">
                    </div>
                    
                    <h2 class="section-title">
                        éŸ³é¢‘åˆ—è¡¨
                        <button class="btn btn-danger" id="clearAudioListBtn">
                            <span>æ¸…ç©ºåˆ—è¡¨</span>
                        </button>
                    </h2>
                <p style="font-size:small;">âœ…ç‚¹å‡»"åŠ è½½"è‡³æ³¢å½¢å›¾æŸ¥çœ‹â†—ï¸</p>
                    <div class="audio-list" id="audioList">
                        <!-- éŸ³é¢‘åˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                    
                    <div class="shortcuts">
                        <h2 class="section-title">æ“ä½œå¿«æ·é”®</h2>
                        <div class="shortcut-item">
                            <span>æ’­æ”¾/æš‚åœ</span>
                            <span class="key">ç©ºæ ¼</span>
                        </div>
                        <div class="shortcut-item">
                            <span>æ’¤é”€</span>
                            <span class="key">Ctrl+Z</span>
                        </div>
                        <div class="shortcut-item">
                            <span>æ¢å¤ï¼ˆåå‘æ’¤é”€ï¼‰</span>
                            <span class="key">Ctrl+Y</span>
                        </div>
                        <div class="shortcut-item">
                            <span>åˆ é™¤ï¼ˆåˆ é™¤é€‰ä¸­åŒºåŸŸï¼‰</span>
                            <span class="key">Delete</span>
                        </div>
                        <div class="shortcut-item">
                            <span>æå–ï¼ˆä»…ä¿ç•™é€‰ä¸­åŒºåŸŸï¼‰</span>
                            <span class="key">Ctrl+K</span>
                        </div>
                        <div class="shortcut-item">
                            <span>å¤åˆ¶ï¼ˆå¤åˆ¶é€‰ä¸­åŒºåŸŸï¼‰</span>
                            <span class="key">Ctrl+C</span>
                        </div>
                        <div class="shortcut-item">
                            <span>å‰ªåˆ‡ï¼ˆå¤åˆ¶å¹¶åˆ é™¤é€‰ä¸­åŒºåŸŸï¼‰</span>
                            <span class="key">Ctrl+X</span>
                        </div>
                        <div class="shortcut-item">
                            <span>ç²˜è´´ï¼ˆæ’å…¥å¤åˆ¶çš„éŸ³é¢‘ï¼‰</span>
                            <span class="key">Ctrl+V</span>
                        </div>
                        <div class="shortcut-item">
                            <span>æš‚å­˜ï¼ˆé€‰ä¸­åŒºåŸŸå­˜åˆ°æš‚å­˜åŒºï¼‰</span>
                            <span class="key">Ctrl+S</span>
                        </div>
                        <!-- æ–°å¢ï¼šæ»šè½®ç¼©æ”¾æç¤º -->
                        <div class="shortcut-item">
                            <span>æ»šè½®ç¼©æ”¾</span>
                            <span class="key">é¼ æ ‡æ»šè½®</span>
                        </div>
                        <!-- æ–°å¢ï¼šä»é€‰æ‹©ç‚¹æ’­æ”¾æç¤º -->
                        <div class="shortcut-item">
                            <span>ä»é€‰æ‹©ç‚¹æ’­æ”¾</span>
                            <span class="key">ç‚¹å‡»é€‰æ‹©ç‚¹+ç©ºæ ¼</span>
                        </div>
                        <!-- æ–°å¢ï¼šå“åº¦æ§åˆ¶æç¤º -->
                        <div class="shortcut-item">
                            <span>å“åº¦æ§åˆ¶</span>
                            <span class="key">å³ä¾§æ»‘åŠ¨æ¡</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="main-panel">
                <div class="section">
                    <h2 class="section-title">éŸ³é¢‘æ³¢å½¢å›¾</h2>
                    
                    <div class="clip-controls">
                       <button class="btn btn-primary" id="saveClipBtn">
                            <span>æš‚å­˜</span>
                        </button>
                        <button class="btn btn-danger" id="deleteBtn">
                            <span>åˆ é™¤</span>
                        </button>
                        <button class="btn btn-warning" id="cutBtn">
                            <span>æå–</span>
                        </button>
                        <button class="btn btn-success" id="exportBtn">
                            <span>å¯¼å‡º</span>
                        </button>
                        <button class="btn btn-outline" id="copyBtn">
                            <span>å¤åˆ¶</span>
                        </button>
                        <button class="btn btn-outline" id="cutToClipboardBtn">
                            <span>å‰ªåˆ‡</span>
                        </button>
                        <button class="btn btn-outline" id="pasteBtn">
                            <span>ç²˜è´´</span>
                        </button>
                        <button class="btn btn-outline" id="undoBtn">
                            <span>æ’¤é”€</span>
                        </button>
                        <button class="btn btn-outline" id="redoBtn">
                            <span>æ¢å¤</span>
                        </button>
                    </div>
                    
                    <!-- ç¼©æ”¾æ§åˆ¶ -->
                    <div class="zoom-controls">
                        <button class="btn btn-outline" id="zoomOutBtn">
                            <span>ç¼©å°</span>
                        </button>
                        <input type="range" class="zoom-slider" id="zoomSlider" min="1" max="25" step="0.1" value="1">
                        <button class="btn btn-outline" id="zoomInBtn">
                            <span>æ”¾å¤§</span>
                        </button>
                        <div class="zoom-value" id="zoomValue">100%</div>
                        <button class="btn btn-outline" id="resetZoomBtn">
                            <span>é‡ç½®</span>
                        </button>
                    </div>
                    
                    <div class="waveform-container">
                        <div id="waveform">
                            <!-- æ³¢å½¢å°†åœ¨è¿™é‡Œç»˜åˆ¶ -->
                            <div class="playhead" id="playhead"></div>
                            <div class="selection" id="selection">
                                <div class="selection-handle start" id="selectionStartHandle"></div>
                                <div class="selection-handle end" id="selectionEndHandle"></div>
                            </div>
                        </div>
                        
                        <!-- æ–°å¢ï¼šå“åº¦æ§åˆ¶æ»‘åŠ¨æ¡ - å·²ä¿®æ”¹å¢åŠ é•¿åº¦ -->
                        <div class="amplitude-control-container">
                            <div class="amplitude-label">å“åº¦</div>
                            <input type="range" class="amplitude-slider" id="amplitudeSlider" min="0" max="2" step="0.01" value="1">
                            <div class="amplitude-value" id="amplitudeValue">100%</div>
                        </div>
                    </div>
                    
                    <!-- æ»šåŠ¨æ¡ -->
                    <div class="scroll-container" id="scrollContainer">
                        <div class="scroll-content" id="scrollContent">
                            <div class="scroll-thumb" id="scrollThumb"></div>
                        </div>
                    </div>
                    
                    <div class="time-display">
                        <span>éŸ³é¢‘: </span>
                        <span id="currentTime">0:00.000</span> / <span id="duration">0:00.000</span>
                        <span id="selectionTime"> | é€‰æ‹©: 0:00.000 - 0:00.000 å…±0ms</span>
                    </div>
                    
                    <div class="playback-controls">
                        <button class="btn btn-outline" id="loopBtn">
                            <span>ğŸ” å¾ªç¯</span>
                        </button>
                        <button class="btn btn-primary" id="playBtn">
                            <span>æ’­æ”¾</span>
                        </button>
                        <button class="btn btn-outline" id="pauseBtn">
                            <span>æš‚åœ</span>
                        </button>
                        <button class="btn btn-outline" id="stopBtn">
                            <span>åœæ­¢</span>
                        </button>
                    </div>
                    
                    <div class="progress">
                        <div class="progress-bar" id="progressBar"></div>
                    </div>
                </div>
                
                <div class="section">
                    <h2 class="section-title">
                        éŸ³é¢‘æš‚å­˜åŒº
                        
                        <button class="btn btn-danger" id="clearClipsBtn">
                            <span>æ¸…ç©ºåˆ—è¡¨</span>
                        </button>
                    </h2>
                    <div style="font-size:medium;margin-bottom: 5px;">ç²˜è´´ï¼šå¤åˆ¶éŸ³é¢‘åæ’å…¥æˆ–è¦†ç›–æ³¢å½¢å›¾ä¸­çš„é€‰ä¸­åŒºåŸŸï¼›åŠ è½½ï¼šæŠŠéŸ³é¢‘ä¸Šè½½åˆ°æ³¢å½¢å›¾ä¸­</div>
                    <div class="clip-list" id="clipList">
                        <!-- éŸ³é¢‘ç‰‡æ®µå°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                    </div>
                    
                    <div style="margin-top: 20;">
                        <button class="btn btn-success" id="mergeBtn">
                            <span>åˆå¹¶ç‰‡æ®µ</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ä¸»è¦å˜é‡
        let audioContext;
        let audioBuffer = null;
        let sourceNode = null;
        let gainNode = null;
        let isPlaying = false;
        let isLooping = false;
        let startTime = 0;
        let pauseTime = 0;
        let currentAudioId = null;
        let selectionStart = 0;
        let selectionEnd = 0;
        let isSelecting = false;
        let clips = [];
        let audioFiles = [];
        let isDraggingSelection = false;
        let dragTarget = null; // 'start', 'end', 'selection'
        let dragStartX = 0;
        let dragStartSelectionStart = 0;
        let dragStartSelectionEnd = 0;
        
        // æ–°å¢ï¼šå‰ªè´´æ¿å˜é‡
        let clipboard = null; // { arrayBuffer, sampleRate, numberOfChannels, duration }
        
        // æ–°å¢ï¼šç¼©æ”¾å’Œæ»šåŠ¨ç›¸å…³å˜é‡
        let zoomLevel = 1.0; // åˆå§‹ç¼©æ”¾çº§åˆ«
        let scrollPosition = 0; // æ»šåŠ¨ä½ç½®ï¼ˆåƒç´ ï¼‰
        let isDraggingScroll = false;
        let dragStartScrollX = 0;
        let dragStartThumbX = 0;
        let waveformCanvas = null;
        let waveformCtx = null;
        let waveformWidth = 0;
        let waveformHeight = 0;
        
        // æ–°å¢ï¼šå³°å€¼é‡‡æ ·ç›¸å…³å˜é‡
        let peakData = null; // å­˜å‚¨å³°å€¼æ•°æ®
        let peakDataLength = 0; // å³°å€¼æ•°æ®é•¿åº¦
        let originalAudioData = null; // å­˜å‚¨åŸå§‹éŸ³é¢‘æ•°æ®
        
        // æ–°å¢ï¼šå½“å‰éŸ³é¢‘æ–‡ä»¶å
        let currentFileName = "audio_export.wav";
        
        // æ–°å¢ï¼šå“åº¦æ§åˆ¶ç›¸å…³å˜é‡
        let amplitudeScale = 1.0; // å“åº¦ç¼©æ”¾å› å­
        let isDraggingAmplitude = false; // æ˜¯å¦æ­£åœ¨æ‹–åŠ¨å“åº¦æ»‘å—
        let tempAmplitudeScale = 1.0; // ä¸´æ—¶å“åº¦ç¼©æ”¾å› å­ï¼ˆç”¨äºæ‹–åŠ¨è¿‡ç¨‹ä¸­çš„é¢„è§ˆï¼‰
        
        // IndexedDB ç›¸å…³å˜é‡
        let db = null;
        const DB_NAME = 'AudioEditorDB';
        const DB_VERSION = 1;
        const STORE_AUDIO_FILES = 'audioFiles';
        const STORE_CLIPS = 'clips';
        const STORE_STATE = 'state';
        
        // æ’¤é”€/æ¢å¤ç³»ç»Ÿ
        let undoStack = [];
        let redoStack = [];
        const MAX_HISTORY = 50; // æœ€å¤§å†å²è®°å½•æ•°é‡
        
        // DOMå…ƒç´ 
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const audioList = document.getElementById('audioList');
        const clearAudioListBtn = document.getElementById('clearAudioListBtn');
        const waveform = document.getElementById('waveform');
        const playhead = document.getElementById('playhead');
        const selection = document.getElementById('selection');
        const selectionStartHandle = document.getElementById('selectionStartHandle');
        const selectionEndHandle = document.getElementById('selectionEndHandle');
        const loopBtn = document.getElementById('loopBtn');
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const currentTimeEl = document.getElementById('currentTime');
        const durationEl = document.getElementById('duration');
        const selectionTimeEl = document.getElementById('selectionTime');
        const progressBar = document.getElementById('progressBar');
        const cutBtn = document.getElementById('cutBtn');
        const deleteBtn = document.getElementById('deleteBtn');
        const saveClipBtn = document.getElementById('saveClipBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const clipList = document.getElementById('clipList');
        const mergeBtn = document.getElementById('mergeBtn');
        const clearClipsBtn = document.getElementById('clearClipsBtn');
        const statusMessage = document.getElementById('statusMessage');
        const autoSaveStatus = document.getElementById('autoSaveStatus');
        
        // æ–°å¢ï¼šå¤åˆ¶ã€å‰ªåˆ‡å’Œç²˜è´´æŒ‰é’®
        const copyBtn = document.getElementById('copyBtn');
        const cutToClipboardBtn = document.getElementById('cutToClipboardBtn');
        const pasteBtn = document.getElementById('pasteBtn');
        
        // æ–°å¢ï¼šç¼©æ”¾å’Œæ»šåŠ¨ç›¸å…³DOMå…ƒç´ 
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomValue = document.getElementById('zoomValue');
        const resetZoomBtn = document.getElementById('resetZoomBtn');
        const scrollContainer = document.getElementById('scrollContainer');
        const scrollContent = document.getElementById('scrollContent');
        const scrollThumb = document.getElementById('scrollThumb');
        
        // æ–°å¢ï¼šå¯¼å‡ºæŒ‰é’®
        const exportBtn = document.getElementById('exportBtn');
        
        // æ–°å¢ï¼šå“åº¦æ§åˆ¶DOMå…ƒç´ 
        const amplitudeSlider = document.getElementById('amplitudeSlider');
        const amplitudeValue = document.getElementById('amplitudeValue');
        
        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', async function() {
            await initIndexedDB();
            initAudioContext();
            setupEventListeners();
            await loadFromIndexedDB();
            updateUI();
            
            // è®¾ç½®è‡ªåŠ¨ä¿å­˜
            setInterval(saveToIndexedDB, 5000);
        });
        
        // åˆå§‹åŒ– IndexedDB
        function initIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => {
                    console.error('IndexedDB åˆå§‹åŒ–å¤±è´¥');
                    reject(request.error);
                };
                
                request.onsuccess = () => {
                    db = request.result;
                    console.log('IndexedDB åˆå§‹åŒ–æˆåŠŸ');
                    resolve();
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // åˆ›å»ºéŸ³é¢‘æ–‡ä»¶å­˜å‚¨
                    if (!db.objectStoreNames.contains(STORE_AUDIO_FILES)) {
                        const audioFilesStore = db.createObjectStore(STORE_AUDIO_FILES, { keyPath: 'id' });
                        audioFilesStore.createIndex('name', 'name', { unique: false });
                    }
                    
                    // åˆ›å»ºéŸ³é¢‘ç‰‡æ®µå­˜å‚¨
                    if (!db.objectStoreNames.contains(STORE_CLIPS)) {
                        const clipsStore = db.createObjectStore(STORE_CLIPS, { keyPath: 'id' });
                        clipsStore.createIndex('name', 'name', { unique: false });
                    }
                    
                    // åˆ›å»ºçŠ¶æ€å­˜å‚¨
                    if (!db.objectStoreNames.contains(STORE_STATE)) {
                        db.createObjectStore(STORE_STATE, { keyPath: 'id' });
                    }
                };
            });
        }
        
        // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
        function initAudioContext() {
            try {
                // å§‹ç»ˆä½¿ç”¨8kHzé‡‡æ ·ç‡
                audioContext = new AudioContext({sampleRate: 8000});
                statusMessage.textContent = "éŸ³é¢‘ä¸Šä¸‹æ–‡å·²åˆå§‹åŒ– (8kHz)";
            } catch (e) {
                statusMessage.textContent = "æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒWeb Audio API";
                console.error("Web Audio API is not supported in this browser", e);
            }
        }
        
        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            // æ–‡ä»¶ä¸Šä¼ 
            uploadArea.addEventListener('click', () => fileInput.click());
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.style.background = 'rgba(52, 152, 219, 0.1)';
            });
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.style.background = '';
            });
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.style.background = '';
                handleFiles(e.dataTransfer.files);
            });
            fileInput.addEventListener('change', () => handleFiles(fileInput.files));
            
            // æ¸…ç©ºéŸ³é¢‘åˆ—è¡¨
            clearAudioListBtn.addEventListener('click', clearAudioList);
            
            // æ’­æ”¾æ§åˆ¶
            loopBtn.addEventListener('click', toggleLoop);
            playBtn.addEventListener('click', playAudio);
            pauseBtn.addEventListener('click', pauseAudio);
            stopBtn.addEventListener('click', stopAudio);
            
            // æå–æ§åˆ¶
            cutBtn.addEventListener('click', cutAudio);
            deleteBtn.addEventListener('click', deleteSelection);
            saveClipBtn.addEventListener('click', saveClip);
            
            // æ–°å¢ï¼šå¤åˆ¶ã€å‰ªåˆ‡å’Œç²˜è´´æŒ‰é’®
            copyBtn.addEventListener('click', copyToClipboard);
            cutToClipboardBtn.addEventListener('click', cutToClipboard);
            pasteBtn.addEventListener('click', pasteFromClipboard);
            
            // æ–°å¢ï¼šå¯¼å‡ºæŒ‰é’®
            exportBtn.addEventListener('click', exportAudio);
            
            // æ’¤é”€/æ¢å¤
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            
            // ç‰‡æ®µç®¡ç†
            mergeBtn.addEventListener('click', mergeClips);
            clearClipsBtn.addEventListener('click', clearClips);
            
            // æ³¢å½¢ç‚¹å‡»äº‹ä»¶
            waveform.addEventListener('mousedown', handleWaveformMouseDown);
            
            // é”®ç›˜å¿«æ·é”®
            document.addEventListener('keydown', handleKeyDown);
            
            // é¼ æ ‡ç§»åŠ¨å’Œé‡Šæ”¾äº‹ä»¶
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            
            // æ–°å¢ï¼šç¼©æ”¾å’Œæ»šåŠ¨äº‹ä»¶
            zoomOutBtn.addEventListener('click', () => adjustZoom(-0.1));
            zoomInBtn.addEventListener('click', () => adjustZoom(0.1));
            zoomSlider.addEventListener('input', () => {
                setZoom(parseFloat(zoomSlider.value));
            });
            resetZoomBtn.addEventListener('click', resetZoom);
            
            // æ»šåŠ¨æ¡äº‹ä»¶
            scrollThumb.addEventListener('mousedown', handleScrollThumbMouseDown);
            scrollContainer.addEventListener('mousedown', handleScrollContainerMouseDown);
            
            // æ–°å¢ï¼šæ»šè½®ç¼©æ”¾äº‹ä»¶
            waveform.addEventListener('wheel', handleWaveformWheel, { passive: false });
            
            // æ–°å¢ï¼šå“åº¦æ§åˆ¶äº‹ä»¶
            amplitudeSlider.addEventListener('input', handleAmplitudeChange);
            amplitudeSlider.addEventListener('mousedown', () => {
                isDraggingAmplitude = true;
                // ä¿å­˜å½“å‰çŠ¶æ€ä½œä¸ºä¸´æ—¶çŠ¶æ€ï¼Œç”¨äºé¢„è§ˆ
                tempAmplitudeScale = amplitudeScale;
            });
            amplitudeSlider.addEventListener('mouseup', handleAmplitudeChangeEnd);
            
            // çª—å£å¤§å°å˜åŒ–æ—¶é‡æ–°ç»˜åˆ¶æ³¢å½¢
            window.addEventListener('resize', () => {
                if (audioBuffer) {
                    drawWaveform();
                }
            });
        }
        
        // æ–°å¢ï¼šå¤„ç†å“åº¦å˜åŒ–
        function handleAmplitudeChange(e) {
            if (!audioBuffer) return;
            
            const value = parseFloat(e.target.value);
            tempAmplitudeScale = value;
            amplitudeValue.textContent = `${Math.round(value * 100)}%`;
            
            // å®æ—¶æ›´æ–°æ³¢å½¢æ˜¾ç¤º
            if (audioBuffer) {
                drawWaveform();
            }
            
            statusMessage.textContent = `å“åº¦è°ƒæ•´: ${Math.round(value * 100)}%`;
        }
        
        // æ–°å¢ï¼šå¤„ç†å“åº¦å˜åŒ–ç»“æŸ
        function handleAmplitudeChangeEnd(e) {
            if (!audioBuffer) return;
            
            isDraggingAmplitude = false;
            const value = parseFloat(e.target.value);
            
            // ä¿å­˜çŠ¶æ€åˆ°å†å²è®°å½•
            saveStateToHistory('å“åº¦è°ƒæ•´');
            
            // åº”ç”¨å“åº¦è°ƒæ•´
            applyAmplitudeScale(value);

            // å»¶è¿Ÿé‡ç½®æ»‘å—ï¼Œç¡®ä¿äº‹ä»¶å¤„ç†å®Œæˆ
            setTimeout(() => {
                amplitudeSlider.value = 1.0;
                amplitudeValue.textContent = '100%';
                tempAmplitudeScale = 1.0;
            }, 100);
            
            statusMessage.textContent = `å·²åº”ç”¨å“åº¦è°ƒæ•´: ${Math.round(value * 100)}%`;
        }
        
        // æ–°å¢ï¼šåº”ç”¨å“åº¦ç¼©æ”¾
        function applyAmplitudeScale(scale) {
            if (!audioBuffer) return;
            
            // ç¡®å®šè°ƒæ•´èŒƒå›´
            const start = Math.min(selectionStart, selectionEnd);
            const end = Math.max(selectionStart, selectionEnd);
            const hasSelection = end > start;
            
            if (hasSelection) {
                // åªè°ƒæ•´é€‰ä¸­åŒºåŸŸ
                const startSample = Math.floor(start * audioBuffer.sampleRate);
                const endSample = Math.floor(end * audioBuffer.sampleRate);
                
                for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                    const channelData = audioBuffer.getChannelData(channel);
                    for (let i = startSample; i < endSample; i++) {
                        channelData[i] = Math.max(-1, Math.min(1, channelData[i] * scale));
                    }
                }
            } else {
                // è°ƒæ•´æ•´ä¸ªéŸ³é¢‘
                for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                    const channelData = audioBuffer.getChannelData(channel);
                    for (let i = 0; i < channelData.length; i++) {
                        channelData[i] = Math.max(-1, Math.min(1, channelData[i] * scale));
                    }
                }
            }
            
            // æ›´æ–°åŸå§‹éŸ³é¢‘æ•°æ®
            originalAudioData = audioBuffer.getChannelData(0);
            
            // é‡æ–°ç”Ÿæˆå³°å€¼æ•°æ®
            generatePeakData();
            
            // é‡æ–°ç»˜åˆ¶æ³¢å½¢
            drawWaveform();
            
            // æ³¨æ„ï¼šè¿™é‡Œåªä¿®æ”¹ä¸»éŸ³é¢‘ï¼Œä¸å½±å“å·²æš‚å­˜çš„ç‰‡æ®µ
            // å› ä¸ºæš‚å­˜çš„ç‰‡æ®µå·²ç»åˆ›å»ºäº†ç‹¬ç«‹çš„å‰¯æœ¬
        }
        
        // å¯¼å‡ºéŸ³é¢‘
        function exportAudio() {
            if (!audioBuffer) {
                statusMessage.textContent = 'è¯·å…ˆåŠ è½½éŸ³é¢‘';
                return;
            }
            
            // å°†AudioBufferè½¬æ¢ä¸ºWAVæ–‡ä»¶
            const wavBlob = audioBufferToWav(audioBuffer);
            const url = URL.createObjectURL(wavBlob);
            
            // åˆ›å»ºä¸‹è½½é“¾æ¥
            const a = document.createElement('a');
            a.href = url;
            a.download = currentFileName;
            document.body.appendChild(a);
            a.click();
            
            // æ¸…ç†
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            
            statusMessage.textContent = `å·²å¯¼å‡ºéŸ³é¢‘: ${currentFileName}`;
        }
        
        // å¤„ç†æ³¢å½¢æ»šè½®äº‹ä»¶
        function handleWaveformWheel(e) {
            if (!audioBuffer) return;
            
            e.preventDefault();
            
            // è®¡ç®—é¼ æ ‡ä½ç½®å¯¹åº”çš„æ—¶é—´
            const rect = waveform.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            
            // è®¡ç®—é¼ æ ‡ä½ç½®å¯¹åº”çš„å½“å‰æ—¶é—´
            const visibleStartTime = (scrollPosition / (waveformWidth * zoomLevel)) * audioBuffer.duration;
            const visibleEndTime = visibleStartTime + (audioBuffer.duration / zoomLevel);
            const mouseTime = visibleStartTime + (mouseX / waveformWidth) * (visibleEndTime - visibleStartTime);
            
            // ç¡®å®šç¼©æ”¾æ–¹å‘ï¼ˆå‘ä¸‹æ»šåŠ¨æ”¾å¤§ï¼Œå‘ä¸Šæ»šåŠ¨ç¼©å°ï¼‰
            const zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
            
            // ä¿å­˜å½“å‰ç¼©æ”¾çº§åˆ«å’Œæ»šåŠ¨ä½ç½®
            const oldZoomLevel = zoomLevel;
            const oldScrollPosition = scrollPosition;
            
            // è®¡ç®—æ–°çš„ç¼©æ”¾çº§åˆ«
            let newZoom = zoomLevel + zoomDelta;
            
            // é™åˆ¶ç¼©æ”¾èŒƒå›´
            if (newZoom < 1.0) {
                newZoom = 1.0;
            }
            if (newZoom > 25.0) {
                newZoom = 25.0;
                statusMessage.textContent = "å·²è¾¾åˆ°æœ€å¤§ç¼©æ”¾çº§åˆ« (2500%)";
            }
            
            // æ›´æ–°ç¼©æ”¾çº§åˆ«
            zoomLevel = newZoom;
            zoomSlider.value = zoomLevel;
            zoomValue.textContent = `${Math.round(zoomLevel * 100)}%`;
            
            // è®¡ç®—æ–°çš„æ»šåŠ¨ä½ç½®ï¼Œä½¿é¼ æ ‡ä½ç½®çš„æ—¶é—´ä¿æŒä¸å˜
            const newVisibleDuration = audioBuffer.duration / zoomLevel;
            const newVisibleStartTime = mouseTime - (mouseX / waveformWidth) * newVisibleDuration;
            
            // ç¡®ä¿æ–°çš„æ»šåŠ¨ä½ç½®åœ¨æœ‰æ•ˆèŒƒå›´å†…
            const maxScroll = waveformWidth * (zoomLevel - 1);
            scrollPosition = Math.max(0, Math.min((newVisibleStartTime / audioBuffer.duration) * (waveformWidth * zoomLevel), maxScroll));
            
            // æ›´æ–°æ»šåŠ¨æ¡
            updateScrollBar();
            
            // é‡æ–°ç»˜åˆ¶æ³¢å½¢
            if (audioBuffer) {
                drawWaveform();
            }
            
            // æ›´æ–°æ’­æ”¾å¤´ä½ç½®
            updatePlayhead();
            
            // æ›´æ–°é€‰æ‹©åŒºåŸŸæ˜¾ç¤º
            updateSelectionDisplay();
            
            statusMessage.textContent = `ç¼©æ”¾çº§åˆ«: ${Math.round(zoomLevel * 100)}%`;
        }
        
        // å¤åˆ¶åˆ°å‰ªè´´æ¿
        function copyToClipboard() {
            if (!audioBuffer || selectionStart === selectionEnd) {
                statusMessage.textContent = 'è¯·å…ˆé€‰æ‹©è¦å¤åˆ¶çš„åŒºåŸŸ';
                return;
            }
            
            // ä½¿ç”¨æ­£ç¡®çš„æ—¶é—´èŒƒå›´ï¼ˆç¡®ä¿å¼€å§‹æ—¶é—´å°äºç»“æŸæ—¶é—´ï¼‰
            const start = Math.min(selectionStart, selectionEnd);
            const end = Math.max(selectionStart, selectionEnd);
            const duration = end - start;
            
            // åˆ›å»ºæ–°çš„AudioBufferå­˜å‚¨å¤åˆ¶å†…å®¹
            const copyBuffer = audioContext.createBuffer(
                audioBuffer.numberOfChannels,
                duration * audioBuffer.sampleRate,
                audioBuffer.sampleRate
            );
            
            // å¤åˆ¶é€‰ä¸­çš„æ•°æ®åˆ°å‰ªè´´æ¿
            for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                const originalData = audioBuffer.getChannelData(channel);
                const copyData = copyBuffer.getChannelData(channel);
                
                const startSample = Math.floor(start * audioBuffer.sampleRate);
                const endSample = Math.floor(end * audioBuffer.sampleRate);
                
                for (let i = startSample, j = 0; i < endSample; i++, j++) {
                    copyData[j] = originalData[i];
                }
            }
            
            // å°†å¤åˆ¶å†…å®¹ä¿å­˜åˆ°å‰ªè´´æ¿
            clipboard = {
                arrayBuffer: audioBufferToArrayBuffer(copyBuffer),
                sampleRate: audioBuffer.sampleRate,
                numberOfChannels: audioBuffer.numberOfChannels,
                duration: duration
            };
            
            statusMessage.textContent = `å·²å¤åˆ¶éŸ³é¢‘åŒºåŸŸåˆ°å‰ªè´´æ¿: ${formatTime(start)} - ${formatTime(end)}`;
        }
        
        // å‰ªåˆ‡åˆ°å‰ªè´´æ¿
        function cutToClipboard() {
            if (!audioBuffer || selectionStart === selectionEnd) {
                statusMessage.textContent = 'è¯·å…ˆé€‰æ‹©è¦å‰ªåˆ‡çš„åŒºåŸŸ';
                return;
            }
            
            // ä¿å­˜çŠ¶æ€åˆ°å†å²è®°å½•
            saveStateToHistory('å‰ªåˆ‡');
            
            // ä½¿ç”¨æ­£ç¡®çš„æ—¶é—´èŒƒå›´ï¼ˆç¡®ä¿å¼€å§‹æ—¶é—´å°äºç»“æŸæ—¶é—´ï¼‰
            const start = Math.min(selectionStart, selectionEnd);
            const end = Math.max(selectionStart, selectionEnd);
            const duration = end - start;
            
            // åˆ›å»ºæ–°çš„AudioBufferå­˜å‚¨å‰ªåˆ‡å†…å®¹
            const cutBuffer = audioContext.createBuffer(
                audioBuffer.numberOfChannels,
                duration * audioBuffer.sampleRate,
                audioBuffer.sampleRate
            );
            
            // å¤åˆ¶é€‰ä¸­çš„æ•°æ®åˆ°å‰ªè´´æ¿
            for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                const originalData = audioBuffer.getChannelData(channel);
                const cutData = cutBuffer.getChannelData(channel);
                
                const startSample = Math.floor(start * audioBuffer.sampleRate);
                const endSample = Math.floor(end * audioBuffer.sampleRate);
                
                for (let i = startSample, j = 0; i < endSample; i++, j++) {
                    cutData[j] = originalData[i];
                }
            }
            
            // å°†å‰ªåˆ‡å†…å®¹ä¿å­˜åˆ°å‰ªè´´æ¿
            clipboard = {
                arrayBuffer: audioBufferToArrayBuffer(cutBuffer),
                sampleRate: audioBuffer.sampleRate,
                numberOfChannels: audioBuffer.numberOfChannels,
                duration: duration
            };
            
            // ä»åŸéŸ³é¢‘ä¸­åˆ é™¤é€‰ä¸­åŒºåŸŸ
            const beforeLength = Math.floor(start * audioBuffer.sampleRate);
            const afterLength = audioBuffer.length - Math.floor(end * audioBuffer.sampleRate);
            const totalLength = beforeLength + afterLength;
            
            // åˆ›å»ºæ–°çš„AudioBuffer
            const newBuffer = audioContext.createBuffer(
                audioBuffer.numberOfChannels,
                totalLength,
                audioBuffer.sampleRate
            );
            
            // å¤åˆ¶åˆ é™¤å‰åçš„æ•°æ®
            for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                const originalData = audioBuffer.getChannelData(channel);
                const newData = newBuffer.getChannelData(channel);
                
                // å¤åˆ¶åˆ é™¤å‰çš„æ•°æ®
                for (let i = 0; i < beforeLength; i++) {
                    newData[i] = originalData[i];
                }
                
                // å¤åˆ¶åˆ é™¤åçš„æ•°æ®
                const afterStart = Math.floor(end * audioBuffer.sampleRate);
                for (let i = 0; i < afterLength; i++) {
                    newData[beforeLength + i] = originalData[afterStart + i];
                }
            }
            
            // æ›¿æ¢åŸå§‹buffer
            audioBuffer = newBuffer;
            
            // æ›´æ–°åŸå§‹éŸ³é¢‘æ•°æ®
            originalAudioData = audioBuffer.getChannelData(0);
            
            // é‡æ–°ç”Ÿæˆå³°å€¼æ•°æ®
            generatePeakData();
            
            // é‡ç½®é€‰æ‹©
            resetSelection();
            
            // é‡æ–°ç»˜åˆ¶æ³¢å½¢
            drawWaveform();
            
            statusMessage.textContent = `å·²å‰ªåˆ‡éŸ³é¢‘åŒºåŸŸåˆ°å‰ªè´´æ¿: ${formatTime(start)} - ${formatTime(end)}`;
        }
        
        // ä»å‰ªè´´æ¿ç²˜è´´ - ä¿®å¤ä»å³å¾€å·¦é€‰æ‹©æ—¶ç²˜è´´çš„é—®é¢˜
        function pasteFromClipboard() {
            if (!audioBuffer) {
                statusMessage.textContent = 'è¯·å…ˆåŠ è½½éŸ³é¢‘';
                return;
            }
            
            if (!clipboard) {
                statusMessage.textContent = 'å‰ªè´´æ¿ä¸ºç©ºï¼Œè¯·å…ˆå¤åˆ¶æˆ–å‰ªåˆ‡éŸ³é¢‘';
                return;
            }
            
            // ä¿å­˜çŠ¶æ€åˆ°å†å²è®°å½•
            saveStateToHistory('ç²˜è´´');
            
            // å°†å‰ªè´´æ¿ä¸­çš„ArrayBufferè½¬æ¢ä¸ºAudioBuffer
            const pasteBuffer = arrayBufferToAudioBuffer(
                clipboard.arrayBuffer,
                clipboard.numberOfChannels,
                Math.floor(clipboard.duration * clipboard.sampleRate),
                clipboard.sampleRate
            );
            
            // ç¡®å®šç²˜è´´ä½ç½® - ä¿®å¤ï¼šæ— è®ºä»å·¦å¾€å³è¿˜æ˜¯ä»å³å¾€å·¦é€‰æ‹©ï¼Œéƒ½ä½¿ç”¨æ­£ç¡®çš„æ—¶é—´èŒƒå›´
            const pasteStart = Math.min(selectionStart, selectionEnd);
            const pasteEnd = Math.max(selectionStart, selectionEnd);
            
            // å¦‚æœé€‰æ‹©åŒºåŸŸæœ‰é•¿åº¦ï¼Œåˆ™æ›¿æ¢è¯¥åŒºåŸŸï¼›å¦åˆ™åœ¨èµ·å§‹ä½ç½®æ’å…¥
            const hasSelection = pasteEnd > pasteStart;
            
            // è®¡ç®—æ–°éŸ³é¢‘çš„é•¿åº¦
            const originalLength = audioBuffer.length;
            const pasteLength = pasteBuffer.length;
            let newLength;
            
            if (hasSelection) {
                // æ›¿æ¢æ¨¡å¼ï¼šåˆ é™¤é€‰ä¸­åŒºåŸŸï¼Œç„¶åæ’å…¥å‰ªè´´æ¿å†…å®¹
                const selectionLength = Math.floor((pasteEnd - pasteStart) * audioBuffer.sampleRate);
                newLength = originalLength - selectionLength + pasteLength;
            } else {
                // æ’å…¥æ¨¡å¼ï¼šåœ¨èµ·å§‹ä½ç½®æ’å…¥å‰ªè´´æ¿å†…å®¹
                newLength = originalLength + pasteLength;
            }
            
            // åˆ›å»ºæ–°çš„AudioBuffer
            const newBuffer = audioContext.createBuffer(
                audioBuffer.numberOfChannels,
                newLength,
                audioBuffer.sampleRate
            );
            
            // æ‰§è¡Œç²˜è´´æ“ä½œ
            for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                const originalData = audioBuffer.getChannelData(channel);
                const pasteData = pasteBuffer.getChannelData(channel);
                const newData = newBuffer.getChannelData(channel);
                
                const startSample = Math.floor(pasteStart * audioBuffer.sampleRate);
                
                if (hasSelection) {
                    // æ›¿æ¢æ¨¡å¼
                    const endSample = Math.floor(pasteEnd * audioBuffer.sampleRate);
                    const selectionLength = endSample - startSample;
                    
                    // å¤åˆ¶ç²˜è´´ç‚¹ä¹‹å‰çš„æ•°æ®
                    for (let i = 0; i < startSample; i++) {
                        newData[i] = originalData[i];
                    }
                    
                    // æ’å…¥å‰ªè´´æ¿å†…å®¹
                    for (let i = 0; i < pasteLength; i++) {
                        newData[startSample + i] = pasteData[i];
                    }
                    
                    // å¤åˆ¶ç²˜è´´ç‚¹ä¹‹åçš„æ•°æ®
                    for (let i = endSample; i < originalLength; i++) {
                        newData[startSample + pasteLength + (i - endSample)] = originalData[i];
                    }
                } else {
                    // æ’å…¥æ¨¡å¼
                    // å¤åˆ¶ç²˜è´´ç‚¹ä¹‹å‰çš„æ•°æ®
                    for (let i = 0; i < startSample; i++) {
                        newData[i] = originalData[i];
                    }
                    
                    // æ’å…¥å‰ªè´´æ¿å†…å®¹
                    for (let i = 0; i < pasteLength; i++) {
                        newData[startSample + i] = pasteData[i];
                    }
                    
                    // å¤åˆ¶ç²˜è´´ç‚¹ä¹‹åçš„æ•°æ®
                    for (let i = startSample; i < originalLength; i++) {
                        newData[startSample + pasteLength + (i - startSample)] = originalData[i];
                    }
                }
            }
            
            // æ›¿æ¢åŸå§‹buffer
            audioBuffer = newBuffer;
            
            // æ›´æ–°åŸå§‹éŸ³é¢‘æ•°æ®
            originalAudioData = audioBuffer.getChannelData(0);
            
            // é‡æ–°ç”Ÿæˆå³°å€¼æ•°æ®
            generatePeakData();
            
            // ä¿®æ”¹ï¼šç²˜è´´åè‡ªåŠ¨é€‰æ‹©ç²˜è´´çš„å†…å®¹
            selectionStart = pasteStart;
            selectionEnd = pasteStart + clipboard.duration;
            
            // é‡æ–°ç»˜åˆ¶æ³¢å½¢
            drawWaveform();
            
            // æ›´æ–°é€‰æ‹©åŒºåŸŸæ˜¾ç¤º
            updateSelectionDisplay();
            
            statusMessage.textContent = hasSelection ? 
                `å·²ç”¨å‰ªè´´æ¿å†…å®¹æ›¿æ¢é€‰ä¸­åŒºåŸŸå¹¶è‡ªåŠ¨é€‰ä¸­ç²˜è´´å†…å®¹` : 
                `å·²åœ¨ ${formatTime(pasteStart)} å¤„æ’å…¥å‰ªè´´æ¿å†…å®¹å¹¶è‡ªåŠ¨é€‰ä¸­ç²˜è´´å†…å®¹`;
        }
        
        // è°ƒæ•´ç¼©æ”¾
        function adjustZoom(delta) {
            let newZoom = zoomLevel + delta;
            
            // é™åˆ¶æœ€å°ç¼©æ”¾çº§åˆ«
            if (newZoom < 1.0) {
                newZoom = 1.0;
            }
            
            // é™åˆ¶æœ€å¤§ç¼©æ”¾çº§åˆ«
            if (newZoom > 25.0) {
                newZoom = 25.0;
                statusMessage.textContent = "å·²è¾¾åˆ°æœ€å¤§ç¼©æ”¾çº§åˆ« (2500%)";
            }
            
            setZoom(newZoom);
        }
        
        // è®¾ç½®ç¼©æ”¾çº§åˆ«
        function setZoom(newZoom) {
            if (!audioBuffer) {
                zoomLevel = newZoom;
                zoomSlider.value = zoomLevel;
                zoomValue.textContent = `${Math.round(zoomLevel * 100)}%`;
                return;
            }
            
            // è®¡ç®—å½“å‰å¯è§åŒºåŸŸçš„ä¸­å¿ƒæ—¶é—´
            const visibleStartTime = (scrollPosition / (waveformWidth * zoomLevel)) * audioBuffer.duration;
            const visibleEndTime = visibleStartTime + (audioBuffer.duration / zoomLevel);
            const centerTime = visibleStartTime + (visibleEndTime - visibleStartTime) / 2;
            
            // æ›´æ–°ç¼©æ”¾çº§åˆ«
            zoomLevel = newZoom;
            zoomSlider.value = zoomLevel;
            zoomValue.textContent = `${Math.round(zoomLevel * 100)}%`;
            
            // è®¡ç®—æ–°çš„æ»šåŠ¨ä½ç½®ï¼Œä½¿ä¸­å¿ƒæ—¶é—´ä¿æŒä¸å˜
            const newVisibleDuration = audioBuffer.duration / zoomLevel;
            const newVisibleStartTime = Math.max(0, Math.min(centerTime - newVisibleDuration / 2, audioBuffer.duration - newVisibleDuration));
            scrollPosition = (newVisibleStartTime / audioBuffer.duration) * (waveformWidth * zoomLevel);
            
            // æ›´æ–°æ»šåŠ¨æ¡
            updateScrollBar();
            
            // é‡æ–°ç»˜åˆ¶æ³¢å½¢
            if (audioBuffer) {
                drawWaveform();
            }
            
            // æ›´æ–°æ’­æ”¾å¤´ä½ç½®
            updatePlayhead();
            
            // æ›´æ–°é€‰æ‹©åŒºåŸŸæ˜¾ç¤º
            updateSelectionDisplay();
            
            statusMessage.textContent = `ç¼©æ”¾çº§åˆ«: ${Math.round(zoomLevel * 100)}%`;
        }
        
        // é‡ç½®ç¼©æ”¾
        function resetZoom() {
            setZoom(1.0);
            scrollPosition = 0;
            updateScrollBar();
            
            if (audioBuffer) {
                drawWaveform();
            }
            
            statusMessage.textContent = "ç¼©æ”¾å·²é‡ç½®";
        }
        
        // å¤„ç†æ»šåŠ¨æ¡æ»‘å—é¼ æ ‡æŒ‰ä¸‹
        function handleScrollThumbMouseDown(e) {
            e.preventDefault();
            isDraggingScroll = true;
            dragStartScrollX = e.clientX;
            dragStartThumbX = parseFloat(scrollThumb.style.left || '0');
            
            document.addEventListener('mousemove', handleScrollMouseMove);
            document.addEventListener('mouseup', handleScrollMouseUp);
        }
        
        // å¤„ç†æ»šåŠ¨æ¡å®¹å™¨é¼ æ ‡æŒ‰ä¸‹
        function handleScrollContainerMouseDown(e) {
            if (e.target === scrollContainer || e.target === scrollContent) {
                const rect = scrollContainer.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const thumbWidth = parseFloat(scrollThumb.style.width || '100');
                const thumbLeft = Math.max(0, Math.min(clickX - thumbWidth / 2, 100 - thumbWidth));
                
                scrollThumb.style.left = `${thumbLeft}%`;
                updateScrollPositionFromThumb();
            }
        }
        
        // å¤„ç†æ»šåŠ¨æ¡é¼ æ ‡ç§»åŠ¨
        function handleScrollMouseMove(e) {
            if (!isDraggingScroll) return;
            
            const deltaX = e.clientX - dragStartScrollX;
            const containerWidth = scrollContainer.clientWidth;
            const thumbWidth = parseFloat(scrollThumb.style.width || '100');
            const maxThumbLeft = 100 - thumbWidth;
            
            let newThumbLeft = dragStartThumbX + (deltaX / containerWidth) * 100;
            newThumbLeft = Math.max(0, Math.min(newThumbLeft, maxThumbLeft));
            
            scrollThumb.style.left = `${newThumbLeft}%`;
            updateScrollPositionFromThumb();
        }
        
        // å¤„ç†æ»šåŠ¨æ¡é¼ æ ‡é‡Šæ”¾
        function handleScrollMouseUp() {
            isDraggingScroll = false;
            document.removeEventListener('mousemove', handleScrollMouseMove);
            document.removeEventListener('mouseup', handleScrollMouseUp);
        }
        
        // ä»æ»‘å—ä½ç½®æ›´æ–°æ»šåŠ¨ä½ç½®
        function updateScrollPositionFromThumb() {
            const thumbLeft = parseFloat(scrollThumb.style.left || '0');
            const thumbWidth = parseFloat(scrollThumb.style.width || '100');
            const maxThumbLeft = 100 - thumbWidth;
            
            if (maxThumbLeft > 0) {
                scrollPosition = (thumbLeft / maxThumbLeft) * (waveformWidth * (zoomLevel - 1));
            } else {
                scrollPosition = 0;
            }
            
            if (audioBuffer) {
                drawWaveform();
                updatePlayhead();
                updateSelectionDisplay();
            }
        }
        
        // æ›´æ–°æ»šåŠ¨æ¡
        function updateScrollBar() {
            if (!audioBuffer) {
                scrollThumb.style.width = '100%';
                scrollThumb.style.left = '0%';
                return;
            }
            
            // è®¡ç®—æ»‘å—å®½åº¦
            const thumbWidth = Math.max(10, 100 / zoomLevel);
            scrollThumb.style.width = `${thumbWidth}%`;
            
            // è®¡ç®—æ»‘å—ä½ç½®
            const maxScroll = waveformWidth * (zoomLevel - 1);
            if (maxScroll > 0) {
                const thumbLeft = (scrollPosition / maxScroll) * (100 - thumbWidth);
                scrollThumb.style.left = `${Math.max(0, Math.min(thumbLeft, 100 - thumbWidth))}%`;
            } else {
                scrollThumb.style.left = '0%';
            }
            
            // æ˜¾ç¤ºæˆ–éšè—æ»šåŠ¨æ¡
            if (zoomLevel > 1.0) {
                scrollContainer.style.display = 'block';
            } else {
                scrollContainer.style.display = 'none';
            }
        }
        
        // ä¿å­˜çŠ¶æ€åˆ°å†å²è®°å½• - ä¿®å¤ï¼šä¸å†å…‹éš†æ•´ä¸ª AudioBuffer
        function saveStateToHistory(action) {
            // æ¸…é™¤é‡åšæ ˆ
            redoStack = [];
            
            // åªä¿å­˜å¿…è¦çš„çŠ¶æ€ä¿¡æ¯ï¼Œè€Œä¸æ˜¯æ•´ä¸ª AudioBuffer
            const state = {
                // ä¸ä¿å­˜æ•´ä¸ª AudioBufferï¼Œåªä¿å­˜å¿…è¦çš„ä¿¡æ¯
                audioBufferData: audioBuffer ? {
                    arrayBuffer: audioBufferToArrayBuffer(audioBuffer),
                    sampleRate: audioBuffer.sampleRate,
                    numberOfChannels: audioBuffer.numberOfChannels,
                    length: audioBuffer.length
                } : null,
                selectionStart: selectionStart,
                selectionEnd: selectionEnd,
                action: action,
                timestamp: Date.now()
            };
            
            undoStack.push(state);
            
            // é™åˆ¶å†å²è®°å½•æ•°é‡
            if (undoStack.length > MAX_HISTORY) {
                undoStack.shift();
            }
            
            updateUndoRedoButtons();
        }
        
        // ä»ä¿å­˜çš„æ•°æ®æ¢å¤ AudioBuffer
        function restoreAudioBufferFromState(audioBufferData) {
            if (!audioBufferData) return null;
            
            return arrayBufferToAudioBuffer(
                audioBufferData.arrayBuffer,
                audioBufferData.numberOfChannels,
                audioBufferData.length,
                audioBufferData.sampleRate
            );
        }
        
        // æ›´æ–°æ’¤é”€/æ¢å¤æŒ‰é’®çŠ¶æ€
        function updateUndoRedoButtons() {
            undoBtn.disabled = undoStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
        }
        
        // æ’¤é”€æ“ä½œ - ä¿®å¤ï¼šä»ä¿å­˜çš„æ•°æ®æ¢å¤ AudioBuffer
        function undo() {
            if (undoStack.length === 0) return;
            
            // ä¿å­˜å½“å‰çŠ¶æ€åˆ°é‡åšæ ˆ
            const currentState = {
                audioBufferData: audioBuffer ? {
                    arrayBuffer: audioBufferToArrayBuffer(audioBuffer),
                    sampleRate: audioBuffer.sampleRate,
                    numberOfChannels: audioBuffer.numberOfChannels,
                    length: audioBuffer.length
                } : null,
                selectionStart: selectionStart,
                selectionEnd: selectionEnd,
                action: 'current',
                timestamp: Date.now()
            };
            
            redoStack.push(currentState);
            
            // æ¢å¤ä¸Šä¸€ä¸ªçŠ¶æ€
            const previousState = undoStack.pop();
            audioBuffer = previousState.audioBufferData ? 
                restoreAudioBufferFromState(previousState.audioBufferData) : null;
            selectionStart = previousState.selectionStart;
            selectionEnd = previousState.selectionEnd;
            
            // æ›´æ–°UI
            if (audioBuffer) {
                // æ›´æ–°åŸå§‹éŸ³é¢‘æ•°æ®
                originalAudioData = audioBuffer.getChannelData(0);
                generatePeakData();
                drawWaveform();
                updateDurationDisplay();
                updateSelectionDisplay();
            } else {
                waveform.innerHTML = '';
                durationEl.textContent = '0:00.000';
                resetSelection();
            }
            
            updateUndoRedoButtons();
            
            statusMessage.textContent = `å·²æ’¤é”€: ${previousState.action}`;
        }
        
        // æ¢å¤æ“ä½œ - ä¿®å¤ï¼šä»ä¿å­˜çš„æ•°æ®æ¢å¤ AudioBuffer
        function redo() {
            if (redoStack.length === 0) return;
            
            // ä¿å­˜å½“å‰çŠ¶æ€åˆ°æ’¤é”€æ ˆ
            const currentState = {
                audioBufferData: audioBuffer ? {
                    arrayBuffer: audioBufferToArrayBuffer(audioBuffer),
                    sampleRate: audioBuffer.sampleRate,
                    numberOfChannels: audioBuffer.numberOfChannels,
                    length: audioBuffer.length
                } : null,
                selectionStart: selectionStart,
                selectionEnd: selectionEnd,
                action: 'current',
                timestamp: Date.now()
            };
            
            undoStack.push(currentState);
            
            // æ¢å¤ä¸‹ä¸€ä¸ªçŠ¶æ€
            const nextState = redoStack.pop();
            audioBuffer = nextState.audioBufferData ? 
                restoreAudioBufferFromState(nextState.audioBufferData) : null;
            selectionStart = nextState.selectionStart;
            selectionEnd = nextState.selectionEnd;
            
            // æ›´æ–°UI
            if (audioBuffer) {
                // æ›´æ–°åŸå§‹éŸ³é¢‘æ•°æ®
                originalAudioData = audioBuffer.getChannelData(0);
                generatePeakData();
                drawWaveform();
                updateDurationDisplay();
                updateSelectionDisplay();
            } else {
                waveform.innerHTML = '';
                durationEl.textContent = '0:00.000';
                resetSelection();
            }
            
            updateUndoRedoButtons();
            
            statusMessage.textContent = `å·²æ¢å¤: ${nextState.action}`;
        }
        
        // å¤„ç†ä¸Šä¼ çš„æ–‡ä»¶
        function handleFiles(files) {
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                // æ”¯æŒWAVã€MP3ã€M4Aæ ¼å¼
                const acceptedTypes = ['audio/wav', 'audio/mpeg', 'audio/mp3', 'audio/mp4', 'audio/x-m4a', 'audio/aac'];
                const acceptedExtensions = ['.wav', '.mp3', '.m4a'];
                const fileName = file.name.toLowerCase();
                
                if (acceptedTypes.includes(file.type) || acceptedExtensions.some(ext => fileName.endsWith(ext))) {
                    addAudioFile(file);
                } else {
                    statusMessage.textContent = `æ–‡ä»¶ ${file.name} ä¸æ˜¯æ”¯æŒçš„éŸ³é¢‘æ ¼å¼ï¼ˆæ”¯æŒWAVã€MP3ã€M4Aï¼‰`;
                }
            }
        }
        
        // æ·»åŠ éŸ³é¢‘æ–‡ä»¶
        function addAudioFile(file) {
            const audioId = 'audio_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            audioFiles.push({
                id: audioId,
                file: file,
                name: file.name,
                url: URL.createObjectURL(file)
            });
            
            updateAudioList();
            saveToIndexedDB();
            statusMessage.textContent = `å·²æ·»åŠ éŸ³é¢‘: ${file.name}`;
        }
        
        // æ¸…ç©ºéŸ³é¢‘åˆ—è¡¨
        function clearAudioList() {
            if (audioFiles.length === 0) {
                statusMessage.textContent = 'éŸ³é¢‘åˆ—è¡¨å·²ç»æ˜¯ç©ºçš„';
                return;
            }
            
            if (confirm('ç¡®å®šè¦æ¸…ç©ºéŸ³é¢‘åˆ—è¡¨å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
                // åœæ­¢å½“å‰æ’­æ”¾
                if (currentAudioId) {
                    stopAudio();
                    audioBuffer = null;
                    currentAudioId = null;
                    resetSelection();
                    waveform.innerHTML = '';
                }
                
                // é‡Šæ”¾æ‰€æœ‰URLå¯¹è±¡
                audioFiles.forEach(audio => {
                    URL.revokeObjectURL(audio.url);
                });
                
                // æ¸…ç©ºéŸ³é¢‘æ–‡ä»¶åˆ—è¡¨
                audioFiles = [];
                updateAudioList();
                saveToIndexedDB();
                statusMessage.textContent = 'å·²æ¸…ç©ºéŸ³é¢‘åˆ—è¡¨';
            }
        }
        
        // æ›´æ–°éŸ³é¢‘åˆ—è¡¨UI
        function updateAudioList() {
            audioList.innerHTML = '';
            
            if (audioFiles.length === 0) {
                audioList.innerHTML = '<div style="text-align: center; padding: 20px; color: #7f8c8d;">æš‚æ— éŸ³é¢‘æ–‡ä»¶</div>';
                return;
            }
            
            audioFiles.forEach(audio => {
                const audioItem = document.createElement('div');
                audioItem.className = `audio-item ${currentAudioId === audio.id ? 'active' : ''}`;
                audioItem.innerHTML = `
                    <div class="audio-name">${audio.name}</div>
                    <div class="audio-controls">
                        <!--<button class="btn btn-outline play-audio" data-id="${audio.id}">æ’­æ”¾</button>-->
                        <button class="btn btn-outline load-audio" style="padding: 7px; font-size: 11px;" data-id="${audio.id}">åŠ è½½</button>
                        <button class="btn btn-danger remove-audio" style="padding: 7px; font-size: 11px;" data-id="${audio.id}">åˆ é™¤</button>
                    </div>
                `;
                audioList.appendChild(audioItem);
            });
            
            // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
            document.querySelectorAll('.play-audio').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const audioId = e.target.dataset.id;
                    playAudioById(audioId);
                });
            });
            
            document.querySelectorAll('.load-audio').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const audioId = e.target.dataset.id;
                    loadAudioById(audioId);
                });
            });
            
            document.querySelectorAll('.remove-audio').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const audioId = e.target.dataset.id;
                    removeAudioById(audioId);
                });
            });
        }
        
        // é€šè¿‡IDæ’­æ”¾éŸ³é¢‘
        function playAudioById(audioId) {
            const audio = audioFiles.find(a => a.id === audioId);
            if (audio) {
                if (currentAudioId !== audioId) {
                    loadAudioById(audioId);
                }
                playAudio();
            }
        }
        
        // æ–°å¢ï¼šé‡é‡‡æ ·å‡½æ•° - å°†éŸ³é¢‘é‡é‡‡æ ·åˆ°8kHz
        async function resampleAudioBuffer(sourceBuffer, targetSampleRate) {
            if (sourceBuffer.sampleRate === targetSampleRate) {
                return sourceBuffer;
            }
            
            const duration = sourceBuffer.length / sourceBuffer.sampleRate;
            const offlineContext = new OfflineAudioContext(
                sourceBuffer.numberOfChannels,
                duration * targetSampleRate,
                targetSampleRate
            );
            
            const source = offlineContext.createBufferSource();
            source.buffer = sourceBuffer;
            source.connect(offlineContext.destination);
            source.start(0);
            
            return await offlineContext.startRendering();
        }
        
        // é€šè¿‡IDåŠ è½½éŸ³é¢‘
        async function loadAudioById(audioId) {
            const audio = audioFiles.find(a => a.id === audioId);
            if (audio) {
                currentAudioId = audioId;
                updateAudioList();
                
                try {
                    const response = await fetch(audio.url);
                    const arrayBuffer = await response.arrayBuffer();
                    
                    // è§£ç éŸ³é¢‘æ•°æ®
                    statusMessage.textContent = `æ­£åœ¨è§£ç éŸ³é¢‘: ${audio.name}...`;
                    let decodedBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    // æ£€æŸ¥é‡‡æ ·ç‡ï¼Œå¦‚æœä¸æ˜¯8kHzï¼Œåˆ™è¿›è¡Œé‡é‡‡æ ·
                    if (decodedBuffer.sampleRate !== 8000) {
                        statusMessage.textContent = `æ­£åœ¨å°†éŸ³é¢‘ä» ${decodedBuffer.sampleRate}Hz è½¬æ¢ä¸º 8000Hz...`;
                        decodedBuffer = await resampleAudioBuffer(decodedBuffer, 8000);
                        statusMessage.textContent = `éŸ³é¢‘å·²è½¬æ¢ä¸º 8000Hz: ${audio.name}`;
                    }
                    
                    audioBuffer = decodedBuffer;
                    
                    // ä¿å­˜åŸå§‹éŸ³é¢‘æ•°æ®
                    originalAudioData = audioBuffer.getChannelData(0);
                    
                    // è®¾ç½®å½“å‰æ–‡ä»¶åï¼ˆä¿æŒåŸå§‹æ‰©å±•åï¼‰
                    const originalExt = audio.name.substring(audio.name.lastIndexOf('.'));
                    currentFileName = audio.name.replace(originalExt, '.wav');
                    
                    // é‡ç½®ç¼©æ”¾å’Œæ»šåŠ¨
                    resetZoom();
                    
                    // é‡ç½®å“åº¦æ§åˆ¶
                    amplitudeSlider.value = 1.0;
                    amplitudeValue.textContent = '100%';
                    tempAmplitudeScale = 1.0;
                    
                    // ç”Ÿæˆå³°å€¼æ•°æ®
                    generatePeakData();
                    
                    drawWaveform();
                    updateDurationDisplay();
                    resetSelection();
                    
                    statusMessage.textContent = `å·²åŠ è½½éŸ³é¢‘: ${audio.name} (${audioBuffer.sampleRate}Hz)`;
                } catch (error) {
                    statusMessage.textContent = `åŠ è½½éŸ³é¢‘å¤±è´¥: ${error.message}`;
                    console.error('Error loading audio:', error);
                }
            }
        }
        
        // ç”Ÿæˆå³°å€¼æ•°æ®
        function generatePeakData() {
            if (!audioBuffer) return;
            
            const data = audioBuffer.getChannelData(0);
            const length = data.length;
            
            // ä½¿ç”¨å›ºå®šæ•°é‡çš„é‡‡æ ·ç‚¹ï¼Œé¿å…æ•°æ®è¿‡å¤§
            const targetPoints = 5000; // ç›®æ ‡é‡‡æ ·ç‚¹æ•°
            const step = Math.max(1, Math.floor(length / targetPoints));
            
            peakData = new Float32Array(Math.ceil(length / step));
            peakDataLength = peakData.length;
            
            // è®¡ç®—æ¯ä¸ªåŒºé—´çš„å³°å€¼
            for (let i = 0; i < peakDataLength; i++) {
                const start = i * step;
                const end = Math.min(start + step, length);
                
                let min = 0;
                let max = 0;
                
                for (let j = start; j < end; j++) {
                    const value = data[j];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
                
                // å­˜å‚¨å³°å€¼èŒƒå›´
                peakData[i] = (max - min) / 2;
            }
        }
        
        // é€šè¿‡IDåˆ é™¤éŸ³é¢‘
        function removeAudioById(audioId) {
            if (currentAudioId === audioId) {
                stopAudio();
                audioBuffer = null;
                currentAudioId = null;
                resetSelection();
                waveform.innerHTML = '';
            }
            
            const audio = audioFiles.find(a => a.id === audioId);
            if (audio) {
                URL.revokeObjectURL(audio.url);
            }
            
            audioFiles = audioFiles.filter(a => a.id !== audioId);
            updateAudioList();
            saveToIndexedDB();
            statusMessage.textContent = 'å·²åˆ é™¤éŸ³é¢‘';
        }
        
        // åˆ‡æ¢å¾ªç¯æ’­æ”¾çŠ¶æ€
        function toggleLoop() {
            isLooping = !isLooping;
            if (isLooping) {
                loopBtn.classList.add('active');
                statusMessage.textContent = 'å¾ªç¯æ’­æ”¾å·²å¯ç”¨';
            } else {
                loopBtn.classList.remove('active');
                statusMessage.textContent = 'å¾ªç¯æ’­æ”¾å·²ç¦ç”¨';
            }
        }
        
        // æ’­æ”¾éŸ³é¢‘ - ä¿®æ”¹ï¼šå½“é€‰æ‹©æ¡†èµ·å§‹ä½ç½®ç­‰äºç»“æŸä½ç½®æ—¶ï¼Œä»é€‰æ‹©æ¡†èµ·å§‹ä½ç½®å¼€å§‹æ’­æ”¾
        function playAudio() {
            if (!audioBuffer) {
                statusMessage.textContent = 'è¯·å…ˆåŠ è½½éŸ³é¢‘';
                return;
            }
            
            if (isPlaying) {
                pauseAudio();
                return;
            }
            
            stopAudioNode();
            
            sourceNode = audioContext.createBufferSource();
            gainNode = audioContext.createGain();
            
            sourceNode.buffer = audioBuffer;
            sourceNode.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // æ–°å¢ï¼šå¦‚æœé€‰æ‹©äº†åŒºåŸŸï¼Œåªæ’­æ”¾é€‰ä¸­éƒ¨åˆ†ï¼Œä½¿ç”¨æ­£ç¡®çš„æ—¶é—´èŒƒå›´
            let startOffset = 0;
            let duration = audioBuffer.duration;
            
            // ä½¿ç”¨æ­£ç¡®çš„æ—¶é—´èŒƒå›´ï¼ˆç¡®ä¿å¼€å§‹æ—¶é—´å°äºç»“æŸæ—¶é—´ï¼‰
            const start = Math.min(selectionStart, selectionEnd);
            const end = Math.max(selectionStart, selectionEnd);
            
            // ä¿®å¤ï¼šå¦‚æœæœ‰æš‚åœæ—¶é—´ï¼Œä»æš‚åœä½ç½®ç»§ç»­æ’­æ”¾
            if (pauseTime > 0) {
                startOffset = pauseTime;
                // å¦‚æœæœ‰é€‰æ‹©åŒºåŸŸï¼Œç¡®ä¿åœ¨è¯¥åŒºåŸŸå†…æ’­æ”¾
                if (end > start) {
                    duration = end - startOffset;
                } else {
                    duration = audioBuffer.duration - startOffset;
                }
            } else {
                if (end > start) {
                    // æ’­æ”¾é€‰ä¸­åŒºåŸŸ
                    startOffset = start;
                    duration = end - start;
                } else if (start === end && start > 0) {
                    // å½“é€‰æ‹©åŒºåŸŸåªæ˜¯ä¸€ä¸ªç‚¹ï¼ˆèµ·å§‹ç­‰äºç»“æŸï¼‰æ—¶ï¼Œä»è¯¥ç‚¹å¼€å§‹æ’­æ”¾åˆ°éŸ³é¢‘ç»“æŸ
                    startOffset = start;
                    duration = audioBuffer.duration - start;
                }
                // å¦‚æœstartç­‰äºendä¸”ç­‰äº0ï¼Œåˆ™æ’­æ”¾æ•´ä¸ªéŸ³é¢‘
            }
            
            sourceNode.start(0, startOffset, duration);
            startTime = audioContext.currentTime - startOffset;
            isPlaying = true;
            
            // ä¿®å¤ï¼šæ·»åŠ æ’­æ”¾ç»“æŸäº‹ä»¶ç›‘å¬ï¼Œæ”¯æŒå¾ªç¯æ’­æ”¾
            sourceNode.onended = () => {
                if (isLooping && audioBuffer) {
                    // å¾ªç¯æ’­æ”¾ï¼šé‡ç½®pauseTimeå¹¶é‡æ–°æ’­æ”¾
                    pauseTime = 0;
                    playAudio();
                } else {
                    // æ­£å¸¸ç»“æŸ
                    isPlaying = false;
                    pauseTime = 0;
                    updatePlayButton();
                    updatePlayhead();
                    statusMessage.textContent = 'æ’­æ”¾ç»“æŸ';
                }
            };
            
            updatePlayButton();
            requestAnimationFrame(updatePlayhead);
            
            statusMessage.textContent = 'æ­£åœ¨æ’­æ”¾éŸ³é¢‘';
        }
        
        // æš‚åœéŸ³é¢‘ - ä¿®å¤ï¼šä¿æŒå½“å‰æ’­æ”¾ä½ç½®ï¼Œä¸é‡ç½®åˆ°èµ·ç‚¹
        function pauseAudio() {
            if (isPlaying && sourceNode) {
                // ä¿å­˜å½“å‰æ’­æ”¾ä½ç½®
                pauseTime = audioContext.currentTime - startTime;
                sourceNode.stop();
                isPlaying = false;
                updatePlayButton();
                // ä¸æ›´æ–°playheadï¼Œä¿æŒåœ¨å½“å‰ä½ç½®
                statusMessage.textContent = 'éŸ³é¢‘å·²æš‚åœ';
            }
        }
        
        // åœæ­¢éŸ³é¢‘ - é‡ç½®pauseTimeåˆ°0å¹¶ç§»åŠ¨playheadåˆ°èµ·ç‚¹
        function stopAudio() {
            if (sourceNode) {
                sourceNode.stop();
                sourceNode = null;
            }
            
            isPlaying = false;
            pauseTime = 0;  // åªæœ‰åœæ­¢æ—¶æ‰é‡ç½®pauseTime
            updatePlayButton();
            updatePlayhead();  // ç§»åŠ¨playheadåˆ°èµ·ç‚¹
            statusMessage.textContent = 'éŸ³é¢‘å·²åœæ­¢';
        }
        
        // åœæ­¢éŸ³é¢‘èŠ‚ç‚¹
        function stopAudioNode() {
            if (sourceNode) {
                try {
                    sourceNode.stop();
                } catch (e) {
                    // èŠ‚ç‚¹å¯èƒ½å·²ç»åœæ­¢ï¼Œå¿½ç•¥é”™è¯¯
                }
                sourceNode = null;
            }
        }
        
        // æ›´æ–°æ’­æ”¾æŒ‰é’®çŠ¶æ€
        function updatePlayButton() {
            if (isPlaying) {
                playBtn.innerHTML = '<span>æš‚åœ</span>';
            } else {
                playBtn.innerHTML = '<span>æ’­æ”¾</span>';
            }
        }
        
        // æ›´æ–°æ’­æ”¾å¤´ä½ç½®
        function updatePlayhead() {
            if (!audioBuffer) return;
            
            let currentTime = 0;
            if (isPlaying) {
                currentTime = audioContext.currentTime - startTime;
            } else {
                currentTime = pauseTime;
            }
            
            // ä½¿ç”¨æ­£ç¡®çš„æ—¶é—´èŒƒå›´ï¼ˆç¡®ä¿å¼€å§‹æ—¶é—´å°äºç»“æŸæ—¶é—´ï¼‰
            const start = Math.min(selectionStart, selectionEnd);
            const end = Math.max(selectionStart, selectionEnd);
            
            // é™åˆ¶åœ¨å½“å‰é€‰æ‹©çš„åŒºåŸŸå†…
            if (end > start) {
                currentTime = Math.max(start, Math.min(currentTime, end));
            } else if (start === end && start > 0) {
                // å½“é€‰æ‹©åŒºåŸŸåªæ˜¯ä¸€ä¸ªç‚¹æ—¶ï¼Œæ’­æ”¾ä»è¯¥ç‚¹åˆ°ç»“æŸ
                currentTime = Math.max(start, Math.min(currentTime, audioBuffer.duration));
            } else {
                currentTime = Math.max(0, Math.min(currentTime, audioBuffer.duration));
            }
            
            // è®¡ç®—æ’­æ”¾å¤´åœ¨æ³¢å½¢å›¾ä¸Šçš„ä½ç½®ï¼ˆè€ƒè™‘ç¼©æ”¾å’Œæ»šåŠ¨ï¼‰
            const progress = currentTime / audioBuffer.duration;
            const visibleStartTime = (scrollPosition / (waveformWidth * zoomLevel)) * audioBuffer.duration;
            const visibleEndTime = visibleStartTime + (audioBuffer.duration / zoomLevel);
            
            if (currentTime >= visibleStartTime && currentTime <= visibleEndTime) {
                const visibleProgress = (currentTime - visibleStartTime) / (visibleEndTime - visibleStartTime);
                playhead.style.left = `${visibleProgress * 100}%`;
                playhead.style.display = 'block';
            } else {
                playhead.style.display = 'none';
            }
            
            progressBar.style.width = `${progress * 100}%`;
            
            currentTimeEl.textContent = formatTime(currentTime);
            
            if (isPlaying) {
                requestAnimationFrame(updatePlayhead);
            }
        }
        
        // ç»˜åˆ¶æ³¢å½¢ - å·²ä¼˜åŒ–ï¼Œä¿®å¤å¤±çœŸé—®é¢˜ï¼Œå¹¶æ·»åŠ å“åº¦æ§åˆ¶é¢„è§ˆ
        function drawWaveform() {
            if (!audioBuffer || !peakData) return;
            
            waveform.innerHTML = '';
            waveformWidth = waveform.clientWidth;
            waveformHeight = waveform.clientHeight;
            
            // åˆ›å»ºcanvas
            waveformCanvas = document.createElement('canvas');
            waveformCanvas.width = waveformWidth;
            waveformCanvas.height = waveformHeight;
            waveform.appendChild(waveformCanvas);
            
            waveformCtx = waveformCanvas.getContext('2d');
            
            // ç»˜åˆ¶èƒŒæ™¯
            waveformCtx.fillStyle = '#1a2530';
            waveformCtx.fillRect(0, 0, waveformWidth, waveformHeight);
            
            // è®¡ç®—å¯è§åŒºåŸŸå¯¹åº”çš„å³°å€¼æ•°æ®ç´¢å¼•
            const visibleStartTime = (scrollPosition / (waveformWidth * zoomLevel)) * audioBuffer.duration;
            const visibleEndTime = visibleStartTime + (audioBuffer.duration / zoomLevel);
            
            const totalDuration = audioBuffer.duration;
            const startIndex = Math.floor((visibleStartTime / totalDuration) * peakDataLength);
            const endIndex = Math.ceil((visibleEndTime / totalDuration) * peakDataLength);
            
            // ä¿®å¤ï¼šç¡®ä¿æ¯ä¸ªåƒç´ è‡³å°‘æœ‰ä¸€ä¸ªæ•°æ®ç‚¹
            const visibleDataPoints = endIndex - startIndex;
            const pixelsPerPoint = Math.max(1, waveformWidth / visibleDataPoints);
            
            // ç»˜åˆ¶æ³¢å½¢
            waveformCtx.strokeStyle = '#3498db';
            waveformCtx.lineWidth = 1;
            waveformCtx.beginPath();
            
            const amp = waveformHeight / 2;
            const centerY = waveformHeight / 2;
            
            // ç¡®å®šæ˜¯å¦åº”ç”¨å“åº¦ç¼©æ”¾
            const start = Math.min(selectionStart, selectionEnd);
            const end = Math.max(selectionStart, selectionEnd);
            const hasSelection = end > start;
            const selectionStartIndex = Math.floor((start / totalDuration) * peakDataLength);
            const selectionEndIndex = Math.ceil((end / totalDuration) * peakDataLength);
            
            // ä¿®å¤ï¼šä½¿ç”¨æ›´ç²¾ç¡®çš„ç»˜åˆ¶æ–¹æ³•ï¼Œé˜²æ­¢å¤±çœŸ
            if (visibleDataPoints > waveformWidth) {
                // æ•°æ®ç‚¹å¤šäºåƒç´ æ•°ï¼Œä½¿ç”¨å³°å€¼é‡‡æ ·
                const pointsPerPixel = visibleDataPoints / waveformWidth;
                
                for (let i = 0; i < waveformWidth; i++) {
                    const dataStart = Math.floor(startIndex + i * pointsPerPixel);
                    const dataEnd = Math.floor(startIndex + (i + 1) * pointsPerPixel);
                    
                    if (dataStart >= peakDataLength || dataEnd < 0) continue;
                    
                    let maxPeak = 0;
                    for (let j = Math.max(0, dataStart); j < Math.min(dataEnd, peakDataLength); j++) {
                        let peak = peakData[j];
                        
                        // åº”ç”¨å“åº¦ç¼©æ”¾é¢„è§ˆ
                        if (isDraggingAmplitude) {
                            if (!hasSelection || (j >= selectionStartIndex && j <= selectionEndIndex)) {
                                peak = Math.min(1, peak * tempAmplitudeScale);
                            }
                        }
                        
                        if (peak > maxPeak) maxPeak = peak;
                    }
                    
                    const peakHeight = maxPeak * amp * 2;
                    
                    if (i === 0) {
                        waveformCtx.moveTo(i, centerY - peakHeight / 2);
                        waveformCtx.lineTo(i, centerY + peakHeight / 2);
                    } else {
                        waveformCtx.moveTo(i, centerY - peakHeight / 2);
                        waveformCtx.lineTo(i, centerY + peakHeight / 2);
                    }
                }
            } else {
                // æ•°æ®ç‚¹å°‘äºåƒç´ æ•°ï¼Œä½¿ç”¨æ’å€¼
                for (let i = 0; i < waveformWidth; i++) {
                    const dataIndex = Math.floor(startIndex + (i / waveformWidth) * visibleDataPoints);
                    
                    if (dataIndex < 0 || dataIndex >= peakDataLength) continue;
                    
                    let peak = peakData[dataIndex];
                    
                    // åº”ç”¨å“åº¦ç¼©æ”¾é¢„è§ˆ
                    if (isDraggingAmplitude) {
                        if (!hasSelection || (dataIndex >= selectionStartIndex && dataIndex <= selectionEndIndex)) {
                            peak = Math.min(1, peak * tempAmplitudeScale);
                        }
                    }
                    
                    const peakHeight = peak * amp * 2;
                    
                    if (i === 0) {
                        waveformCtx.moveTo(i, centerY - peakHeight / 2);
                        waveformCtx.lineTo(i, centerY + peakHeight / 2);
                    } else {
                        waveformCtx.moveTo(i, centerY - peakHeight / 2);
                        waveformCtx.lineTo(i, centerY + peakHeight / 2);
                    }
                }
            }
            
            waveformCtx.stroke();
            
            // é‡æ–°æ·»åŠ æ’­æ”¾å¤´å’Œé€‰æ‹©åŒºåŸŸ
            waveform.appendChild(playhead);
            waveform.appendChild(selection);
            selection.appendChild(selectionStartHandle);
            selection.appendChild(selectionEndHandle);
            updateSelectionDisplay();
        }
        
        // å¤„ç†æ³¢å½¢é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
        function handleWaveformMouseDown(e) {
            if (!audioBuffer) return;
            
            const rect = waveform.getBoundingClientRect();
            const x = e.clientX - rect.left;
            
            // è®¡ç®—ç‚¹å‡»ä½ç½®å¯¹åº”çš„æ—¶é—´ï¼ˆè€ƒè™‘ç¼©æ”¾å’Œæ»šåŠ¨ï¼‰
            const visibleStartTime = (scrollPosition / (waveformWidth * zoomLevel)) * audioBuffer.duration;
            const visibleEndTime = visibleStartTime + (audioBuffer.duration / zoomLevel);
            const time = visibleStartTime + (x / waveformWidth) * (visibleEndTime - visibleStartTime);
            
            // è®¡ç®—é€‰æ‹©åŒºåŸŸåœ¨æ³¢å½¢å›¾ä¸Šçš„åƒç´ ä½ç½®ï¼ˆè€ƒè™‘ç¼©æ”¾å’Œæ»šåŠ¨ï¼‰
            const start = Math.min(selectionStart, selectionEnd);
            const end = Math.max(selectionStart, selectionEnd);
            const selectionStartPixel = ((start - visibleStartTime) / (visibleEndTime - visibleStartTime)) * waveformWidth;
            const selectionEndPixel = ((end - visibleStartTime) / (visibleEndTime - visibleStartTime)) * waveformWidth;
            
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†é€‰æ‹©åŒºåŸŸçš„èµ·ç‚¹æˆ–ç»ˆç‚¹æ‰‹æŸ„
            const handleTolerance = 8; // åƒç´ 
            
            if (Math.abs(x - selectionStartPixel) < handleTolerance && end > start) {
                // ç‚¹å‡»äº†èµ·ç‚¹æ‰‹æŸ„
                dragTarget = 'start';
                isDraggingSelection = true;
                dragStartX = x;
                dragStartSelectionStart = start;
                dragStartSelectionEnd = end;
            } else if (Math.abs(x - selectionEndPixel) < handleTolerance && end > start) {
                // ç‚¹å‡»äº†ç»ˆç‚¹æ‰‹æŸ„
                dragTarget = 'end';
                isDraggingSelection = true;
                dragStartX = x;
                dragStartSelectionStart = start;
                dragStartSelectionEnd = end;
            } else if (time >= start && time <= end && end > start) {
                // ç‚¹å‡»äº†é€‰æ‹©åŒºåŸŸå†…éƒ¨
                dragTarget = 'selection';
                isDraggingSelection = true;
                dragStartX = x;
                dragStartSelectionStart = start;
                dragStartSelectionEnd = end;
            } else {
                // ç‚¹å‡»äº†é€‰æ‹©åŒºåŸŸå¤–éƒ¨ï¼Œè®¾ç½®æ–°çš„é€‰æ‹©åŒºåŸŸ
                selectionStart = time;
                selectionEnd = time;
                dragTarget = 'new';
                isDraggingSelection = true;
                dragStartX = x;
                dragStartSelectionStart = selectionStart;
                dragStartSelectionEnd = selectionEnd;
            }
    
            updateSelectionDisplay();
            statusMessage.textContent = `æ­£åœ¨è°ƒæ•´é€‰æ‹©åŒºåŸŸ...`;
        }
        
        // å¤„ç†é¼ æ ‡ç§»åŠ¨äº‹ä»¶
        function handleMouseMove(e) {
            if (!isDraggingSelection || !audioBuffer) return;
            
            const rect = waveform.getBoundingClientRect();
            const x = e.clientX - rect.left;
            
            // è®¡ç®—é¼ æ ‡ä½ç½®å¯¹åº”çš„æ—¶é—´ï¼ˆè€ƒè™‘ç¼©æ”¾å’Œæ»šåŠ¨ï¼‰
            const visibleStartTime = (scrollPosition / (waveformWidth * zoomLevel)) * audioBuffer.duration;
            const visibleEndTime = visibleStartTime + (audioBuffer.duration / zoomLevel);
            const time = visibleStartTime + (x / waveformWidth) * (visibleEndTime - visibleStartTime);
            
            const deltaX = x - dragStartX;
            const deltaTime = (deltaX / waveformWidth) * (visibleEndTime - visibleStartTime);
            
            // è·å–å½“å‰é€‰æ‹©åŒºåŸŸçš„æ­£ç¡®è¾¹ç•Œ
            const currentStart = Math.min(selectionStart, selectionEnd);
            const currentEnd = Math.max(selectionStart, selectionEnd);
            
            if (dragTarget === 'start') {
                // æ‹–åŠ¨èµ·ç‚¹æ‰‹æŸ„
                selectionStart = Math.max(0, Math.min(time, currentEnd));
                selectionEnd = currentEnd;
            } else if (dragTarget === 'end') {
                // æ‹–åŠ¨ç»ˆç‚¹æ‰‹æŸ„
                selectionStart = currentStart;
                selectionEnd = Math.max(currentStart, Math.min(time, audioBuffer.duration));
            } else if (dragTarget === 'selection') {
                // æ‹–åŠ¨æ•´ä¸ªé€‰æ‹©åŒºåŸŸ
                const selectionWidth = currentEnd - currentStart;
                const newStart = Math.max(0, Math.min(dragStartSelectionStart + deltaTime, audioBuffer.duration - selectionWidth));
                const newEnd = newStart + selectionWidth;
                
                if (newEnd <= audioBuffer.duration) {
                    selectionStart = newStart;
                    selectionEnd = newEnd;
                }
            } else if (dragTarget === 'new') {
                // åˆ›å»ºæ–°çš„é€‰æ‹©åŒºåŸŸ
                selectionEnd = Math.max(0, Math.min(time, audioBuffer.duration));
            }
            
            updateSelectionDisplay();
        }
        
        // å¤„ç†é¼ æ ‡é‡Šæ”¾äº‹ä»¶
        function handleMouseUp(e) {
            if (isDraggingSelection) {
                isDraggingSelection = false;
                dragTarget = null;
                updateSelectionTimeDisplay();
                
                // æ–°å¢ï¼šæ˜¾ç¤ºé€‰æ‹©åŒºåŸŸï¼ˆä½¿ç”¨æ­£ç¡®çš„æ—¶é—´é¡ºåºï¼‰
                const start = Math.min(selectionStart, selectionEnd);
                const end = Math.max(selectionStart, selectionEnd);
                statusMessage.textContent = `é€‰æ‹©åŒºåŸŸ: ${formatTime(start)} - ${formatTime(end)}`;
                saveToIndexedDB();
            }
        }
        
        // æ›´æ–°é€‰æ‹©åŒºåŸŸæ˜¾ç¤º
        function updateSelectionDisplay() {
            if (!audioBuffer) return;
            
            // è®¡ç®—å¯è§åŒºåŸŸ
            const visibleStartTime = (scrollPosition / (waveformWidth * zoomLevel)) * audioBuffer.duration;
            const visibleEndTime = visibleStartTime + (audioBuffer.duration / zoomLevel);
            
            // ä½¿ç”¨æ­£ç¡®çš„æ—¶é—´èŒƒå›´ï¼ˆç¡®ä¿å¼€å§‹æ—¶é—´å°äºç»“æŸæ—¶é—´ï¼‰
            const start = Math.min(selectionStart, selectionEnd);
            const end = Math.max(selectionStart, selectionEnd);
            
            // è®¡ç®—é€‰æ‹©åŒºåŸŸåœ¨å¯è§åŒºåŸŸå†…çš„ä½ç½®
            const startPercent = ((start - visibleStartTime) / (visibleEndTime - visibleStartTime)) * 100;
            const endPercent = ((end - visibleStartTime) / (visibleEndTime - visibleStartTime)) * 100;
            
            // é™åˆ¶é€‰æ‹©åŒºåŸŸåœ¨å¯è§åŒºåŸŸå†…
            const clampedStartPercent = Math.max(0, Math.min(100, startPercent));
            const clampedEndPercent = Math.max(0, Math.min(100, endPercent));
            
            selection.style.left = `${clampedStartPercent}%`;
            selection.style.width = `${Math.abs(clampedEndPercent - clampedStartPercent)}%`;
            
            // æ›´æ–°é€‰æ‹©æ—¶é—´æ˜¾ç¤º
            updateSelectionTimeDisplay();
        }
        
        // æ›´æ–°é€‰æ‹©æ—¶é—´æ˜¾ç¤º
        function updateSelectionTimeDisplay() {
            // æ–°å¢ï¼šæ˜¾ç¤ºé€‰æ‹©åŒºåŸŸï¼ˆä½¿ç”¨æ­£ç¡®çš„æ—¶é—´é¡ºåºï¼‰
            const start = Math.min(selectionStart, selectionEnd);
            const end = Math.max(selectionStart, selectionEnd);
            const lastSec = Math.floor((end - start) * 1000);
            selectionTimeEl.textContent = ` | é€‰æ‹©: ${formatTime(start)} - ${formatTime(end)} å…±${lastSec}ms`;
        }
        
        // æå–éŸ³é¢‘
        function cutAudio() {
            if (!audioBuffer || selectionStart === selectionEnd) {
                statusMessage.textContent = 'è¯·å…ˆé€‰æ‹©è¦æå–çš„åŒºåŸŸ';
                return;
            }
            
            // ä¿å­˜çŠ¶æ€åˆ°å†å²è®°å½•
            saveStateToHistory('æå–');
            
            // æ–°å¢ï¼šä½¿ç”¨æ­£ç¡®çš„æ—¶é—´èŒƒå›´ï¼ˆç¡®ä¿å¼€å§‹æ—¶é—´å°äºç»“æŸæ—¶é—´ï¼‰
            const start = Math.min(selectionStart, selectionEnd);
            const end = Math.max(selectionStart, selectionEnd);
            const duration = end - start;
            
            // åˆ›å»ºæ–°çš„AudioBuffer
            const newBuffer = audioContext.createBuffer(
                audioBuffer.numberOfChannels,
                duration * audioBuffer.sampleRate,
                audioBuffer.sampleRate
            );
            
            // å¤åˆ¶é€‰ä¸­çš„æ•°æ®
            for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                const originalData = audioBuffer.getChannelData(channel);
                const newData = newBuffer.getChannelData(channel);
                
                const startSample = Math.floor(start * audioBuffer.sampleRate);
                const endSample = Math.floor(end * audioBuffer.sampleRate);
                
                for (let i = startSample, j = 0; i < endSample; i++, j++) {
                    newData[j] = originalData[i];
                }
            }
            
            // æ›¿æ¢åŸå§‹buffer
            audioBuffer = newBuffer;
            
            // æ›´æ–°åŸå§‹éŸ³é¢‘æ•°æ®
            originalAudioData = audioBuffer.getChannelData(0);
            
            // é‡æ–°ç”Ÿæˆå³°å€¼æ•°æ®
            generatePeakData();
            
            // é‡ç½®é€‰æ‹©
            resetSelection();
            
            // é‡æ–°ç»˜åˆ¶æ³¢å½¢
            drawWaveform();
            
            statusMessage.textContent = `å·²æå–éŸ³é¢‘åŒºåŸŸ: ${formatTime(start)} - ${formatTime(end)}`;
        }
        
        // åˆ é™¤é€‰ä¸­åŒºåŸŸ
        function deleteSelection() {
            if (!audioBuffer || selectionStart === selectionEnd) {
                statusMessage.textContent = 'è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„åŒºåŸŸ';
                return;
            }
            
            // ä¿å­˜çŠ¶æ€åˆ°å†å²è®°å½•
            saveStateToHistory('åˆ é™¤');
            
            // æ–°å¢ï¼šä½¿ç”¨æ­£ç¡®çš„æ—¶é—´èŒƒå›´ï¼ˆç¡®ä¿å¼€å§‹æ—¶é—´å°äºç»“æŸæ—¶é—´ï¼‰
            const start = Math.min(selectionStart, selectionEnd);
            const end = Math.max(selectionStart, selectionEnd);
            
            // è®¡ç®—åˆ é™¤åçš„é•¿åº¦
            const beforeLength = Math.floor(start * audioBuffer.sampleRate);
            const afterLength = audioBuffer.length - Math.floor(end * audioBuffer.sampleRate);
            const totalLength = beforeLength + afterLength;
            
            // åˆ›å»ºæ–°çš„AudioBuffer
            const newBuffer = audioContext.createBuffer(
                audioBuffer.numberOfChannels,
                totalLength,
                audioBuffer.sampleRate
            );
            
            // å¤åˆ¶åˆ é™¤å‰åçš„æ•°æ®
            for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                const originalData = audioBuffer.getChannelData(channel);
                const newData = newBuffer.getChannelData(channel);
                
                // å¤åˆ¶åˆ é™¤å‰çš„æ•°æ®
                for (let i = 0; i < beforeLength; i++) {
                    newData[i] = originalData[i];
                }
                
                // å¤åˆ¶åˆ é™¤åçš„æ•°æ®
                const afterStart = Math.floor(end * audioBuffer.sampleRate);
                for (let i = 0; i < afterLength; i++) {
                    newData[beforeLength + i] = originalData[afterStart + i];
                }
            }
            
            // æ›¿æ¢åŸå§‹buffer
            audioBuffer = newBuffer;
            
            // æ›´æ–°åŸå§‹éŸ³é¢‘æ•°æ®
            originalAudioData = audioBuffer.getChannelData(0);
            
            // é‡æ–°ç”Ÿæˆå³°å€¼æ•°æ®
            generatePeakData();
            
            // é‡ç½®é€‰æ‹©
            resetSelection();
            
            // é‡æ–°ç»˜åˆ¶æ³¢å½¢
            drawWaveform();
            
            statusMessage.textContent = `å·²åˆ é™¤éŸ³é¢‘åŒºåŸŸ: ${formatTime(start)} - ${formatTime(end)}`;
        }
        
        // æš‚å­˜ç‰‡æ®µ - ä¿®å¤ï¼šåˆ›å»ºå®Œå…¨ç‹¬ç«‹çš„å‰¯æœ¬
        function saveClip() {
            if (!audioBuffer || selectionStart === selectionEnd) {
                statusMessage.textContent = 'è¯·å…ˆé€‰æ‹©è¦æš‚å­˜çš„åŒºåŸŸ';
                return;
            }
            
            // æ–°å¢ï¼šä½¿ç”¨æ­£ç¡®çš„æ—¶é—´èŒƒå›´ï¼ˆç¡®ä¿å¼€å§‹æ—¶é—´å°äºç»“æŸæ—¶é—´ï¼‰
            const start = Math.min(selectionStart, selectionEnd);
            const end = Math.max(selectionStart, selectionEnd);
            const duration = end - start;
            
            // åˆ›å»ºæ–°çš„AudioBuffer - å®Œå…¨ç‹¬ç«‹çš„å‰¯æœ¬
            const newBuffer = audioContext.createBuffer(
                audioBuffer.numberOfChannels,
                duration * audioBuffer.sampleRate,
                audioBuffer.sampleRate
            );
            
            // å¤åˆ¶é€‰ä¸­çš„æ•°æ® - æ·±æ‹·è´
            for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                const originalData = audioBuffer.getChannelData(channel);
                const newData = newBuffer.getChannelData(channel);
                
                const startSample = Math.floor(start * audioBuffer.sampleRate);
                const endSample = Math.floor(end * audioBuffer.sampleRate);
                
                for (let i = startSample, j = 0; i < endSample; i++, j++) {
                    newData[j] = originalData[i]; // è¿™æ˜¯å€¼çš„å¤åˆ¶ï¼Œä¸æ˜¯å¼•ç”¨
                }
            }
            
            // å°†AudioBufferè½¬æ¢ä¸ºArrayBufferä»¥ä¾¿å­˜å‚¨ - è¿™æ˜¯å…³é”®æ­¥éª¤
            const arrayBuffer = audioBufferToArrayBuffer(newBuffer);
            
            // æ·»åŠ åˆ°ç‰‡æ®µåˆ—è¡¨
            const clipId = 'clip_' + Date.now();
            clips.push({
                id: clipId,
                arrayBuffer: arrayBuffer, // å­˜å‚¨ç‹¬ç«‹çš„ArrayBuffer
                name: `ç‰‡æ®µ_${clips.length + 1}`,
                start: start,
                end: end,
                sampleRate: audioBuffer.sampleRate,
                numberOfChannels: audioBuffer.numberOfChannels
                // æ³¨æ„ï¼šä¸å­˜å‚¨audioBufferå¼•ç”¨ï¼Œç¡®ä¿ç‹¬ç«‹æ€§
            });
            
            updateClipList();
            saveToIndexedDB();
            
            statusMessage.textContent = `å·²æš‚å­˜ç‰‡æ®µ: ${formatTime(start)} - ${formatTime(end)}`;
        }
        
        // å°†AudioBufferè½¬æ¢ä¸ºArrayBuffer
        function audioBufferToArrayBuffer(audioBuffer) {
            const numberOfChannels = audioBuffer.numberOfChannels;
            const length = audioBuffer.length;
            const sampleRate = audioBuffer.sampleRate;
            
            // åˆ›å»ºä¸€ä¸ªArrayBufferæ¥å­˜å‚¨æ‰€æœ‰é€šé“çš„æ•°æ®
            const buffer = new ArrayBuffer(numberOfChannels * length * 4); // 4 bytes per float32
            const view = new DataView(buffer);
            
            let offset = 0;
            for (let channel = 0; channel < numberOfChannels; channel++) {
                const channelData = audioBuffer.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    view.setFloat32(offset, channelData[i], true);
                    offset += 4;
                }
            }
            
            return buffer;
        }
        
        // å°†ArrayBufferè½¬æ¢ä¸ºAudioBuffer
        function arrayBufferToAudioBuffer(arrayBuffer, numberOfChannels, length, sampleRate) {
            const audioBuffer = audioContext.createBuffer(numberOfChannels, length, sampleRate);
            const view = new DataView(arrayBuffer);
            
            let offset = 0;
            for (let channel = 0; channel < numberOfChannels; channel++) {
                const channelData = audioBuffer.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    channelData[i] = view.getFloat32(offset, true);
                    offset += 4;
                }
            }
            
            return audioBuffer;
        }
        
        // æ›´æ–°ç‰‡æ®µåˆ—è¡¨
        function updateClipList() {
            clipList.innerHTML = '';
            
            if (clips.length === 0) {
                clipList.innerHTML = '<div style="text-align: center; padding: 20px; color: #7f8c8d;">æš‚æ— éŸ³é¢‘ç‰‡æ®µ</div>';
                return;
            }
            
            clips.forEach((clip, index) => {
                const clipItem = document.createElement('div');
                clipItem.className = 'clip-item';
                clipItem.innerHTML = `
                    <div class="clip-order-controls">
                        <button class="order-btn move-up" data-id="${clip.id}" ${index === 0 ? 'disabled' : ''}>â†‘</button>
                        <button class="order-btn move-down" data-id="${clip.id}" ${index === clips.length - 1 ? 'disabled' : ''}>â†“</button>
                    </div>
                    <input type="checkbox" class="clip-checkbox" data-id="${clip.id}">
                    <div class="clip-name">${clip.name} (${formatTime(clip.end - clip.start)})</div>
                    <div class="clip-controls-buttons">
                        <button class="btn btn-outline rename-clip" data-id="${clip.id}">æ”¹å</button>
                        <button class="btn btn-outline play-clip" data-id="${clip.id}">æ’­æ”¾</button>
                        <button class="btn btn-outline pause-clip" data-id="${clip.id}">æš‚åœ</button>
                        <button class="btn btn-outline stop-clip" data-id="${clip.id}">åœæ­¢</button>
                        <button class="btn btn-outline copy-clip" data-id="${clip.id}">å¤åˆ¶</button>
                        <button class="btn btn-warning paste-clip" data-id="${clip.id}">ç²˜è´´</button>
                        <button class="btn btn-primary load-clip" data-id="${clip.id}">åŠ è½½</button>
                        <button class="btn btn-success save-clip" data-id="${clip.id}">å¯¼å‡º</button>
                        <button class="btn btn-danger remove-clip" data-id="${clip.id}">åˆ é™¤</button>
                    </div>
                `;
                clipList.appendChild(clipItem);
            });
            
            // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
            document.querySelectorAll('.play-clip').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const clipId = e.target.dataset.id;
                    playClipById(clipId);
                });
            });
            
            document.querySelectorAll('.pause-clip').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    pauseAudio();
                });
            });
            
            document.querySelectorAll('.stop-clip').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    stopAudio();
                });
            });
            
            // æ–°å¢ï¼šå¤åˆ¶æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
            document.querySelectorAll('.copy-clip').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const clipId = e.target.dataset.id;
                    copyClip(clipId);
                });
            });
            
            // æ–°å¢ï¼šç²˜è´´æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
            document.querySelectorAll('.paste-clip').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const clipId = e.target.dataset.id;
                    copyClip(clipId);
                    pasteFromClipboard();
                });
            });
            
            // æ–°å¢ï¼šé‡å‘½åæŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
            document.querySelectorAll('.rename-clip').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const clipId = e.target.dataset.id;
                    renameClip(clipId);
                });
            });
            
            document.querySelectorAll('.save-clip').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const clipId = e.target.dataset.id;
                    saveClipToFile(clipId);
                });
            });
            
            document.querySelectorAll('.load-clip').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const clipId = e.target.dataset.id;
                    loadClipToWaveform(clipId);
                });
            });
            
            document.querySelectorAll('.remove-clip').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const clipId = e.target.dataset.id;
                    removeClipById(clipId);
                });
            });
            
            // æ·»åŠ é¡ºåºè°ƒæ•´äº‹ä»¶ç›‘å¬å™¨
            document.querySelectorAll('.move-up').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const clipId = e.target.dataset.id;
                    moveClipUp(clipId);
                });
            });
            
            document.querySelectorAll('.move-down').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const clipId = e.target.dataset.id;
                    moveClipDown(clipId);
                });
            });
        }
        
        // æ–°å¢ï¼šå¤åˆ¶ç‰‡æ®µåˆ°å‰ªè´´æ¿
        function copyClip(clipId) {
            const clip = clips.find(c => c.id === clipId);
            if (!clip) return;
            
            // ä»ArrayBufferåˆ›å»ºç‹¬ç«‹çš„AudioBuffer
            const audioBuffer = arrayBufferToAudioBuffer(
                clip.arrayBuffer,
                clip.numberOfChannels,
                Math.floor((clip.end - clip.start) * clip.sampleRate),
                clip.sampleRate
            );
            
            if (audioBuffer) {
                // å°†ç‰‡æ®µä¿å­˜åˆ°å‰ªè´´æ¿
                clipboard = {
                    arrayBuffer: audioBufferToArrayBuffer(audioBuffer),
                    sampleRate: clip.sampleRate,
                    numberOfChannels: clip.numberOfChannels,
                    duration: clip.end - clip.start
                };
                
                statusMessage.textContent = `å·²å¤åˆ¶ç‰‡æ®µåˆ°å‰ªè´´æ¿: ${clip.name}`;
            } else {
                statusMessage.textContent = 'æ— æ³•å¤åˆ¶ç‰‡æ®µ: éŸ³é¢‘æ•°æ®ä¸¢å¤±';
            }
        }
        
        // æ–°å¢ï¼šé‡å‘½åç‰‡æ®µåŠŸèƒ½
        function renameClip(clipId) {
            const clip = clips.find(c => c.id === clipId);
            if (!clip) return;
            
            const newName = prompt('è¯·è¾“å…¥æ–°çš„ç‰‡æ®µåç§°ï¼š', clip.name);
            if (newName && newName.trim() !== '') {
                clip.name = newName.trim();
                updateClipList();
                saveToIndexedDB();
                statusMessage.textContent = `å·²é‡å‘½åç‰‡æ®µä¸º: ${clip.name}`;
            }
        }
        
        // ä¸Šç§»ç‰‡æ®µ
        function moveClipUp(clipId) {
            const index = clips.findIndex(c => c.id === clipId);
            if (index > 0) {
                // äº¤æ¢ä½ç½®
                [clips[index], clips[index - 1]] = [clips[index - 1], clips[index]];
                updateClipList();
                saveToIndexedDB();
                statusMessage.textContent = 'å·²ä¸Šç§»ç‰‡æ®µ';
            }
        }
        
        // ä¸‹ç§»ç‰‡æ®µ
        function moveClipDown(clipId) {
            const index = clips.findIndex(c => c.id === clipId);
            if (index < clips.length - 1) {
                // äº¤æ¢ä½ç½®
                [clips[index], clips[index + 1]] = [clips[index + 1], clips[index]];
                updateClipList();
                saveToIndexedDB();
                statusMessage.textContent = 'å·²ä¸‹ç§»ç‰‡æ®µ';
            }
        }
        
        // æ’­æ”¾ç‰‡æ®µ - ä¿®å¤ï¼šä»ç‹¬ç«‹çš„ArrayBufferåˆ›å»ºAudioBuffer
        function playClipById(clipId) {
            const clip = clips.find(c => c.id === clipId);
            if (clip) {
                // ä»ArrayBufferåˆ›å»ºç‹¬ç«‹çš„AudioBuffer
                const clipAudioBuffer = arrayBufferToAudioBuffer(
                    clip.arrayBuffer,
                    clip.numberOfChannels,
                    Math.floor((clip.end - clip.start) * clip.sampleRate),
                    clip.sampleRate
                );
                
                if (clipAudioBuffer) {
                    stopAudioNode();
                    
                    sourceNode = audioContext.createBufferSource();
                    gainNode = audioContext.createGain();
                    
                    sourceNode.buffer = clipAudioBuffer;
                    sourceNode.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    sourceNode.start();
                    isPlaying = true;
                    
                    // ä¿®å¤ï¼šæ·»åŠ æ’­æ”¾ç»“æŸäº‹ä»¶ç›‘å¬
                    sourceNode.onended = () => {
                        isPlaying = false;
                        updatePlayButton();
                        statusMessage.textContent = `ç‰‡æ®µæ’­æ”¾ç»“æŸ: ${clip.name}`;
                    };
                    
                    updatePlayButton();
                    statusMessage.textContent = `æ­£åœ¨æ’­æ”¾ç‰‡æ®µ: ${clip.name}`;
                } else {
                    statusMessage.textContent = 'æ— æ³•æ’­æ”¾ç‰‡æ®µ: éŸ³é¢‘æ•°æ®ä¸¢å¤±';
                }
            }
        }
        
        // ä¿å­˜ç‰‡æ®µåˆ°æ–‡ä»¶
        function saveClipToFile(clipId) {
            const clip = clips.find(c => c.id === clipId);
            if (!clip) return;
            
            // ä»ArrayBufferåˆ›å»ºç‹¬ç«‹çš„AudioBuffer
            const audioBuffer = arrayBufferToAudioBuffer(
                clip.arrayBuffer,
                clip.numberOfChannels,
                Math.floor((clip.end - clip.start) * clip.sampleRate),
                clip.sampleRate
            );
            
            if (audioBuffer) {
                // å°†AudioBufferè½¬æ¢ä¸ºWAVæ–‡ä»¶
                const wavBlob = audioBufferToWav(audioBuffer);
                const url = URL.createObjectURL(wavBlob);
                
                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const a = document.createElement('a');
                a.href = url;
                a.download = `${clip.name}.wav`;
                document.body.appendChild(a);
                a.click();
                
                // æ¸…ç†
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
                
                statusMessage.textContent = `å·²å¯¼å‡ºç‰‡æ®µ: ${clip.name}.wav`;
            } else {
                statusMessage.textContent = 'æ— æ³•å¯¼å‡ºç‰‡æ®µ: éŸ³é¢‘æ•°æ®ä¸¢å¤±';
            }
        }
        
        // å°†AudioBufferè½¬æ¢ä¸ºWAV Blob
        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16; // 16-bit
            
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = buffer.length * blockAlign;
            
            const bufferArray = new ArrayBuffer(44 + dataSize);
            const view = new DataView(bufferArray);
            
            // WAVæ–‡ä»¶å¤´
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            
            // å†™å…¥éŸ³é¢‘æ•°æ®
            let offset = 44;
            for (let i = 0; i < buffer.length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
            }
            
            return new Blob([bufferArray], { type: 'audio/wav' });
        }
        
        // è¾…åŠ©å‡½æ•°ï¼šå†™å…¥å­—ç¬¦ä¸²åˆ°DataView
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
        
        // åŠ è½½ç‰‡æ®µåˆ°æ³¢å½¢å›¾ - ä¿®å¤ï¼šä»ç‹¬ç«‹çš„ArrayBufferåˆ›å»ºAudioBuffer
        function loadClipToWaveform(clipId) {
            const clip = clips.find(c => c.id === clipId);
            if (clip) {
                // åœæ­¢å½“å‰æ’­æ”¾
                stopAudio();
                
                // ä»ArrayBufferåˆ›å»ºç‹¬ç«‹çš„AudioBuffer
                const clipAudioBuffer = arrayBufferToAudioBuffer(
                    clip.arrayBuffer,
                    clip.numberOfChannels,
                    Math.floor((clip.end - clip.start) * clip.sampleRate),
                    clip.sampleRate
                );
                
                if (clipAudioBuffer) {
                    // å°†ç‰‡æ®µçš„bufferè®¾ç½®ä¸ºä¸»éŸ³é¢‘buffer
                    audioBuffer = clipAudioBuffer;
                    currentAudioId = null;
                    
                    // è®¾ç½®å½“å‰æ–‡ä»¶å
                    currentFileName = clip.name + '.wav';
                    
                    // æ›´æ–°åŸå§‹éŸ³é¢‘æ•°æ®
                    originalAudioData = audioBuffer.getChannelData(0);
                    
                    // é‡ç½®ç¼©æ”¾å’Œæ»šåŠ¨
                    resetZoom();
                    
                    // é‡ç½®å“åº¦æ§åˆ¶
                    amplitudeSlider.value = 1.0;
                    amplitudeValue.textContent = '100%';
                    tempAmplitudeScale = 1.0;
                    
                    // ç”Ÿæˆå³°å€¼æ•°æ®
                    generatePeakData();
                    
                    // æ›´æ–°UI
                    drawWaveform();
                    updateDurationDisplay();
                    resetSelection();
                    
                    statusMessage.textContent = `å·²åŠ è½½ç‰‡æ®µåˆ°æ³¢å½¢å›¾: ${clip.name}`;
                } else {
                    statusMessage.textContent = 'æ— æ³•åŠ è½½ç‰‡æ®µ: éŸ³é¢‘æ•°æ®ä¸¢å¤±';
                }
            }
        }
        
        // åˆ é™¤ç‰‡æ®µ
        function removeClipById(clipId) {
            clips = clips.filter(c => c.id !== clipId);
            updateClipList();
            saveToIndexedDB();
            statusMessage.textContent = 'å·²åˆ é™¤ç‰‡æ®µ';
        }
        
        // åˆå¹¶ç‰‡æ®µ - æŒ‰åˆ—è¡¨é¡ºåºåˆå¹¶
        function mergeClips() {
            if (clips.length < 2) {
                statusMessage.textContent = 'è‡³å°‘éœ€è¦ä¸¤ä¸ªç‰‡æ®µæ‰èƒ½åˆå¹¶';
                return;
            }
            
            // è·å–é€‰ä¸­çš„ç‰‡æ®µï¼ˆæŒ‰åˆ—è¡¨é¡ºåºï¼‰
            const selectedClips = [];
            document.querySelectorAll('.clip-checkbox:checked').forEach(checkbox => {
                const clipId = checkbox.dataset.id;
                const clip = clips.find(c => c.id === clipId);
                if (clip) {
                    selectedClips.push(clip);
                }
            });
            
            if (selectedClips.length < 2) {
                statusMessage.textContent = 'è¯·è‡³å°‘é€‰æ‹©ä¸¤ä¸ªç‰‡æ®µè¿›è¡Œåˆå¹¶';
                return;
            }
            
            // æŒ‰ç…§åˆ—è¡¨é¡ºåºåˆå¹¶ï¼ˆclipsæ•°ç»„çš„é¡ºåºå°±æ˜¯åˆ—è¡¨æ˜¾ç¤ºçš„é¡ºåºï¼‰
            // è®¡ç®—æ€»é•¿åº¦
            let totalLength = 0;
            selectedClips.forEach(clip => {
                // ä»ArrayBufferåˆ›å»ºç‹¬ç«‹çš„AudioBuffer
                const clipAudioBuffer = arrayBufferToAudioBuffer(
                    clip.arrayBuffer,
                    clip.numberOfChannels,
                    Math.floor((clip.end - clip.start) * clip.sampleRate),
                    clip.sampleRate
                );
                
                if (clipAudioBuffer) {
                    totalLength += clipAudioBuffer.length;
                }
            });
            
            if (totalLength === 0) {
                statusMessage.textContent = 'æ— æ³•åˆå¹¶ç‰‡æ®µ: éŸ³é¢‘æ•°æ®ä¸¢å¤±';
                return;
            }
            
            // åˆ›å»ºæ–°çš„AudioBuffer
            const sampleRate = selectedClips[0].sampleRate;
            const numChannels = selectedClips[0].numberOfChannels;
            const newBuffer = audioContext.createBuffer(
                numChannels,
                totalLength,
                sampleRate
            );
            
            // åˆå¹¶æ•°æ® - æŒ‰é¡ºåº
            let offset = 0;
            for (let channel = 0; channel < numChannels; channel++) {
                offset = 0;
                selectedClips.forEach(clip => {
                    // ä»ArrayBufferåˆ›å»ºç‹¬ç«‹çš„AudioBuffer
                    const clipAudioBuffer = arrayBufferToAudioBuffer(
                        clip.arrayBuffer,
                        clip.numberOfChannels,
                        Math.floor((clip.end - clip.start) * clip.sampleRate),
                        clip.sampleRate
                    );
                    
                    if (clipAudioBuffer) {
                        const clipData = clipAudioBuffer.getChannelData(channel);
                        const newData = newBuffer.getChannelData(channel);
                        
                        for (let i = 0; i < clipData.length; i++) {
                            newData[offset + i] = clipData[i];
                        }
                        
                        offset += clipData.length;
                    }
                });
            }
            
            // å°†åˆå¹¶åçš„AudioBufferè½¬æ¢ä¸ºArrayBufferä»¥ä¾¿å­˜å‚¨
            const arrayBuffer = audioBufferToArrayBuffer(newBuffer);
            
            // åˆ›å»ºæ–°çš„ç‰‡æ®µ
            const clipId = 'clip_' + Date.now();
            clips.push({
                id: clipId,
                arrayBuffer: arrayBuffer,
                name: `åˆå¹¶ç‰‡æ®µ_${clips.length + 1}`,
                start: 0,
                end: newBuffer.duration,
                sampleRate: sampleRate,
                numberOfChannels: numChannels
            });
            
            updateClipList();
            saveToIndexedDB();
            
            statusMessage.textContent = `å·²æŒ‰é¡ºåºåˆå¹¶ ${selectedClips.length} ä¸ªç‰‡æ®µ`;
        }
        
        // æ¸…ç©ºç‰‡æ®µåˆ—è¡¨
        function clearClips() {
            if (clips.length === 0) {
                statusMessage.textContent = 'ç‰‡æ®µåˆ—è¡¨å·²ç»æ˜¯ç©ºçš„';
                return;
            }
            
            if (confirm('ç¡®å®šè¦æ¸…ç©ºç‰‡æ®µåˆ—è¡¨å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
                clips = [];
                updateClipList();
                saveToIndexedDB();
                statusMessage.textContent = 'å·²æ¸…ç©ºç‰‡æ®µåˆ—è¡¨';
            }
        }
        
        // é‡ç½®é€‰æ‹©åŒºåŸŸ
        function resetSelection() {
            selectionStart = 0;
            selectionEnd = 0;
            updateSelectionDisplay();
        }
        
        // æ›´æ–°æŒç»­æ—¶é—´æ˜¾ç¤º
        function updateDurationDisplay() {
            if (audioBuffer) {
                durationEl.textContent = formatTime(audioBuffer.duration);
            } else {
                durationEl.textContent = '0:00.000';
            }
        }
        
        // æ ¼å¼åŒ–æ—¶é—´ - å·²ä¿®æ”¹ä¸ºç²¾ç¡®åˆ°æ¯«ç§’
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const millis = Math.floor((seconds % 1) * 1000);
            return `${mins}:${secs < 10 ? '0' : ''}${secs}.${millis < 100 ? (millis < 10 ? '00' : '0') : ''}${millis}`;
        }
        
        // å¤„ç†é”®ç›˜å¿«æ·é”®
        function handleKeyDown(e) {
            // é˜²æ­¢åœ¨è¾“å…¥æ¡†ä¸­è§¦å‘å¿«æ·é”®
            if (e.target.tagName === 'INPUT') return;
            
            switch(e.key) {
                case ' ': // ç©ºæ ¼é”® - æ’­æ”¾/æš‚åœ
                    e.preventDefault();
                    if (isPlaying) {
                        pauseAudio();
                    } else {
                        playAudio();
                    }
                    break;
                case 'k': // Ké”® - æå–
                case 'K':
                    if (e.ctrlKey) {
                      e.preventDefault();
                      cutAudio();
                    }
                    break;
                case 'c': // Cé”® - å¤åˆ¶
                case 'C':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        copyToClipboard();
                    }
                    break;
                case 'x': // Xé”® - å‰ªåˆ‡
                case 'X':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        cutToClipboard();
                    }
                    break;
                case 'v': // Vé”® - ç²˜è´´
                case 'V':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        pasteFromClipboard();
                    }
                    break;
                case 'delete': // Dé”® - åˆ é™¤
                case 'Delete':
                    e.preventDefault();
                    deleteSelection();
                    break;
                case 's': // Sé”® - æš‚å­˜ç‰‡æ®µ
                case 'S':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        saveClip();
                    }
                    break;
                case 'z': // Zé”® - æ’¤é”€
                case 'Z':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        undo();
                    }
                    break;
                case 'y': // Yé”® - æ¢å¤
                case 'Y':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        redo();
                    }
                    break;
            }
        }
        
        // IndexedDB è¾…åŠ©å‡½æ•°
        function saveToIndexedDB() {
            if (!db) return;
            
            const transaction = db.transaction([STORE_CLIPS, STORE_STATE], 'readwrite');
            
            // ä¿å­˜ç‰‡æ®µ - å­˜å‚¨æ•´ä¸ªæ•°ç»„ä»¥ä¿æŒé¡ºåº
            const clipsStore = transaction.objectStore(STORE_CLIPS);
            clipsStore.clear();
            
            // ä¸ºæ¯ä¸ªç‰‡æ®µæ·»åŠ é¡ºåºç´¢å¼•
            clips.forEach((clip, index) => {
                clipsStore.add({
                    id: clip.id,
                    name: clip.name,
                    start: clip.start,
                    end: clip.end,
                    sampleRate: clip.sampleRate,
                    numberOfChannels: clip.numberOfChannels,
                    arrayBuffer: clip.arrayBuffer,
                    order: index
                });
            });
            
            // ä¿å­˜çŠ¶æ€ - ä¿®å¤ï¼šä¸ä¿å­˜æ•´ä¸ª AudioBuffer
            const stateStore = transaction.objectStore(STORE_STATE);
            stateStore.put({
                id: 'currentState',
                currentAudioId: currentAudioId,
                selectionStart: selectionStart,
                selectionEnd: selectionEnd,
                undoStack: undoStack,
                redoStack: redoStack
            });
            
            autoSaveStatus.textContent = `å·²è‡ªåŠ¨ä¿å­˜ (${new Date().toLocaleTimeString()})`;
        }
        
        // ä» IndexedDB åŠ è½½
        async function loadFromIndexedDB() {
            if (!db) return;
            
            try {
                // åŠ è½½ç‰‡æ®µ - æŒ‰é¡ºåºå­—æ®µæ’åº
                const clipsStore = db.transaction(STORE_CLIPS).objectStore(STORE_CLIPS);
                const clipsRequest = clipsStore.getAll();
                clipsRequest.onsuccess = () => {
                    // æŒ‰orderå­—æ®µæ’åºï¼Œå¦‚æœæ²¡æœ‰orderå­—æ®µåˆ™æŒ‰idæ’åº
                    const loadedClips = clipsRequest.result.sort((a, b) => {
                        if (a.order !== undefined && b.order !== undefined) {
                            return a.order - b.order;
                        }
                        // å¦‚æœæ²¡æœ‰orderå­—æ®µï¼ŒæŒ‰idæ’åºï¼ˆä¿æŒå‘åå…¼å®¹ï¼‰
                        return a.id.localeCompare(b.id);
                    });
                    
                    clips = loadedClips.map(clip => ({
                        ...clip
                        // æ³¨æ„ï¼šä¸æ¢å¤audioBufferï¼Œç¡®ä¿ç‹¬ç«‹æ€§
                    }));
                    updateClipList();
                };
                
                // åŠ è½½çŠ¶æ€
                const stateStore = db.transaction(STORE_STATE).objectStore(STORE_STATE);
                const stateRequest = stateStore.get('currentState');
                stateRequest.onsuccess = () => {
                    const state = stateRequest.result;
                    if (state) {
                        currentAudioId = state.currentAudioId;
                        selectionStart = state.selectionStart || 0;
                        selectionEnd = state.selectionEnd || 0;
                        undoStack = state.undoStack || [];
                        redoStack = state.redoStack || [];
                    }
                    
                    updateSelectionTimeDisplay();
                    updateUndoRedoButtons();
                };
                
                statusMessage.textContent = 'å·²æ¢å¤ä¸Šæ¬¡ç¼–è¾‘çŠ¶æ€';
            } catch (error) {
                console.error('Error loading state from IndexedDB:', error);
                statusMessage.textContent = 'æ¢å¤ç¼–è¾‘çŠ¶æ€æ—¶å‡ºé”™';
            }
        }
        
        // æ›´æ–°UIçŠ¶æ€
        function updateUI() {
            // æ ¹æ®å½“å‰çŠ¶æ€æ›´æ–°UIå…ƒç´ 
            const hasAudio = audioBuffer !== null;
            
            playBtn.disabled = !hasAudio;
            pauseBtn.disabled = !hasAudio || !isPlaying;
            stopBtn.disabled = !hasAudio;
            exportBtn.disabled = !hasAudio;
            
            cutBtn.disabled = !hasAudio || selectionStart === selectionEnd;
            deleteBtn.disabled = !hasAudio || selectionStart === selectionEnd;
            saveClipBtn.disabled = !hasAudio || selectionStart === selectionEnd;
            copyBtn.disabled = !hasAudio || selectionStart === selectionEnd;
            
            // æ–°å¢ï¼šå‰ªåˆ‡å’Œç²˜è´´æŒ‰é’®çŠ¶æ€
            cutToClipboardBtn.disabled = !hasAudio || selectionStart === selectionEnd;
            pasteBtn.disabled = !hasAudio || !clipboard;
            
            mergeBtn.disabled = clips.length < 2;
            clearClipsBtn.disabled = clips.length === 0;
            clearAudioListBtn.disabled = audioFiles.length === 0;
            
            // æ›´æ–°ç¼©æ”¾æŒ‰é’®çŠ¶æ€ - ä¿®æ”¹ï¼šæœ€å¤§ç¼©æ”¾çº§åˆ«æ”¹ä¸º25å€ï¼ˆ2500%ï¼‰
            zoomOutBtn.disabled = zoomLevel <= 1.0;
            zoomInBtn.disabled = zoomLevel >= 25.0;
            
            // æ›´æ–°å“åº¦æ§åˆ¶çŠ¶æ€
            amplitudeSlider.disabled = !hasAudio;
            
            updateUndoRedoButtons();
        }
        
        // å®šæœŸæ›´æ–°UI
        setInterval(updateUI, 500);
    </script>
</body>
</html>
